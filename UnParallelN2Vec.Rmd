---
title: "Parallelized_Node2Vec"
author: "Grant Foster"
date: "11/17/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(node2vec)
library(parallel)
library(tictoc)
library(dplyr)
library(magrittr)
library(tidyr)
library(randomForest)
library(pROC)
library(tibble)
library(parallel)
```


```{r}
bats <- dplyr::filter(dat, Frug_Group=="Bats")
save(bats, file="bats.rda")
```

Actually doing the node2vec output
```{r}
tic()
poutput <- list()
for(p in 1:length(seq(0.1, 2.0, by=0.1))){
  qoutput <- list()
  for(q in 1:length(seq(0.1, 2.0, by=0.1))){
      node2vecOutput <- bats %>% select(., Frug_Epitetus, Plant_specific.epiteth) %>% unique() %>% data.frame() %>%   node2vecR(data=., p=seq(0.1, 1.9, by=0.1)[p],q=seq(0.1, 1.9, by=0.1)[q], num_walks=10,walk_length=10,dim=3) #Run Node2Vec
      batstemp <- bats #reset batstemp
      batstemp <- node2vecOutput %>% data.frame() %>% rownames_to_column(., var="Frug_Epitetus") %>% rename(., frugX1=X1, frugX2=X2, frugX3=X3) %>% left_join(batstemp, ., by="Frug_Epitetus") #Add in frugivore node2vec values
      batstemp <- node2vecOutput %>% data.frame() %>% rownames_to_column(., var="Plant_specific.epiteth") %>% rename(., plantX1=X1, plantX2=X2, plantX3=X3) %>% left_join(batstemp, ., by="Plant_specific.epiteth") #Add in plant node2vec values
      
    bats_rf_node2vec <- woodedWalk(batstemp, FrugTraits = c("frugX1","frugX2", "frugX3"), PlantTraits = c("plantX1", "plantX2", "plantX3")) #Run random forest model on node2vec outputs
    AUC_bats_rf_node2vec <- roc(data=bats_rf_node2vec$test, response=real, predictor=S)
    
    qoutput[[q]] <- AUC_bats_rf_node2vec #Save the q output in a list
    qoutput[[q]]$paramslong <- c(paste("q=", seq(0.1, 1.9, by=0.1)[q], sep=""), paste("p=", seq(0.1, 1.9, by=0.1)[p], sep="")) #Save our Node2Vec search paramaters in the list sub-element
    qoutput[[q]]$params <- c(seq(0.1, 1.9, by=0.1)[p], seq(0.1, 1.9, by=0.1)[q])
    }
  
  poutput[[p]] <- qoutput #Now we have a list of all q values for a given p value; save it as an element of a bigger list
  print(paste("q-value", q, "of 19", sep=" "))
}

time <- toc()

time
save(poutput, time, file="N2Vec_Bats_Coarse.rda")
```
Now let's do it in a paralleled way
```{r}

applyNode2VecRf <-function(p, q){
      node2vecOutput <- bats %>% select(., Frug_Epitetus, Plant_specific.epiteth) %>% unique() %>% data.frame() %>%   node2vecR(data=., p=p,q=q, num_walks=36,walk_length=60,dim=3) #Run Node2Vec
      batstemp <- bats #reset batstemp
      batstemp <- node2vecOutput %>% data.frame() %>% rownames_to_column(., var="Frug_Epitetus") %>% rename(., frugX1=X1, frugX2=X2, frugX3=X3) %>% left_join(batstemp, ., by="Frug_Epitetus") #Add in frugivore node2vec values
      batstemp <- node2vecOutput %>% data.frame() %>% rownames_to_column(., var="Plant_specific.epiteth") %>% rename(., plantX1=X1, plantX2=X2, plantX3=X3) %>% left_join(batstemp, ., by="Plant_specific.epiteth") #Add in plant node2vec values
      
    bats_rf_node2vec <- woodedWalk(batstemp, FrugTraits = c("frugX1","frugX2", "frugX3"), PlantTraits = c("plantX1", "plantX2", "plantX3")) #Run random forest model on node2vec outputs
    AUC_bats_rf_node2vec <- roc(data=bats_rf_node2vec$test, response=real, predictor=S)
  return(list(AUC=AUC_bats_rf_node2vec$auc, p=p, q=q, node2vecOutput=node2vecOutput))
}
```

Run our function in parallel (Only gets out AUC value now)

36 walks of length 60 takes ~21 hours

```{r}
tic()
numCores <- detectCores()-1
c5 <- parallel::makeCluster(numCores, type = "PSOCK") #not sure this is actually necessary


qrange <- seq(0.1, 2.0, by=0.1) #Set up range of p and q values
prange <- seq(0.1, 2.0, by=0.1)

#qvals <- rep(qrange, length(prange)) #Iterate all possible q values for a given p, then repeat for the next p
#pvals <- rep(prange, each=length(qrange))

qvals <- rep(x=1.1, 100)
pvals <- rep(x=0.7, 100)

clusterExport(cl=c5, c("qvals","pvals", "applyNode2VecRf", "woodedWalk", "bats"))
clusterEvalQ(cl=c5, {library(node2vec)
library(dplyr)
library(magrittr)
library(tidyr)
library(randomForest)
library(pROC)
library(tibble)})


#output <- mcmapply(mc.cores=numCores, FUN=applyNode2VecRf, p=pvals, q=qvals) #parallellized with mcmapply
output <- clusterMap(cl=c5, fun=applyNode2VecRf, p=pvals, q=qvals) #parallellized with clusterMap (Should include load balancing)


parallel::stopCluster(c5) #stop our cluster
time <- toc()


save(output, file="set100inneighbor.rda")
```

Notes on Node2VecR: After creating our collection of random walks ("corpus"), it perofrms node embedding using the skip-gram model of node2vec. 

Extracting the values. This should be in an apply statement; I'm just inept.
```{r}
stuff <- sapply(output, '[', 4)
key <- data.frame(t(sapply(output, '[', c(2,3))))

get <- function(input){
  input[,1]
}

values <- data.frame(sapply(X=stuff, FUN=get))

values %<>% rownames_to_column(., var="node")
values %<>% pivot_longer(., cols=2:ncol(values), names_to = "name")

key$name <- unique(values$name)

values <- left_join(values, key, by="name")

#pivot_longer(output, cols=1:ncol(output))
#outlong <- data.frame(t(output))
#colnames(outlong) <- c("AUC", "p", "q")
#word2vec(walk_use,type="skip-gram",dim=dims)
```

```{r}
qonly <-data.frame(dplyr::filter(values, p==1))
qonly$q <- as.numeric(qonly$q)
qonly %<>% dplyr::select(., node, value, q)

qwide <- pivot_wider(qonly, names_from = q)

qcov <-cov(qwide[,2:ncol(qwide)])
qcor <-cor(qwide[,2:ncol(qwide)])

ggplot(data = reshape2::melt(qcor), aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile()+ggtitle("Correlation Between Q Values (P=1)")

ggplot(data = reshape2::melt(qcov), aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile()+ggtitle("Covariance Between Q Values (P=1)")
```

```{r}
ponly <-data.frame(dplyr::filter(values, q==1))
ponly$p <- as.numeric(ponly$p)
ponly %<>% dplyr::select(., node, value, p)

pwide <- pivot_wider(ponly, names_from = p)

pcov <-cov(pwide[,2:ncol(pwide)])
pcor <-cor(pwide[,2:ncol(pwide)])

ggplot(data = reshape2::melt(pcor), aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile()+ggtitle("Correlation Between p Values (Q=1)")

ggplot(data = reshape2::melt(pcov), aes(x=Var1, y=Var2, fill=value)) + 
  geom_tile()+ggtitle("Covariance Between p Values (Q=1)")
```


```{r}
library(ggplot2)
class(outlong$AUC)
pdf("coarseNode2VecBatSearch.pdf")
ggplot(data=outlong, aes(x=q, y=p, fill=AUC))+geom_tile()+scale_fill_gradient(low="darkred", high="dodger blue")+theme_classic()
hist(outlong$AUC)
```
It doesn't seem like at least our first variable is correlated, but maybe it's less about the absolute values and more about the relationships between each other. Let's calculate pairwise distance between nodes for each parameter set, and then plot the correlations between those matrices
```{r}
stuff <- sapply(output, '[', 4)
key <- data.frame(t(sapply(output, '[', c(2,3))))

get <- function(input){
  input[,1]
}

values <- array(sapply(X=stuff, FUN=dist), NA, dim=c(11781,400,400))




qvals <- rep(qrange, length(prange)) #Iterate all possible q values for a given p, then repeat for the next p
pvals <- rep(prange, each=length(qrange))


badway <- array(NA, dim=c(11781, length(qrange), length(prange)))

test <- NULL
for(i in 1:400){
  ret <- data.frame(as.numeric(dist(stuff[[i]])), qvals[i], pvals[i]) #Fill the first dim with pairwise distances
  test <- rbind(test, ret)
}

colnames(test) <- c("distance", "q", "p")

unique(ponly$p)

ponly <-data.frame(dplyr::filter(test, q==1))
ponly$p <- as.numeric(ponly$p)
ponly %<>% dplyr::select(., distance, p)

d1 <- dplyr::filter(ponly, p==0.1) %>% select(., distance)
d2 <- dplyr::filter(ponly, p==0.2) %>% select(., distance)
cor(d1, d2)

tic()
pcors <- NULL
for(p1 in 1:length(pvals)){
  for(p2 in 1:length(pvals)){
    d1 <- dplyr::filter(ponly, p==pvals[p1]) %>% select(., distance)
    d2 <- dplyr::filter(ponly, p==pvals[p2]) %>% select(., distance)
    temp <- data.frame(cor(d1,d2), pvals[p1],pvals[p2])
    pcors <- rbind(pcors, temp)
  }
}

qcors <- NULL
for(q1 in 1:length(qvals)){
  for(q2 in 1:length(qvals)){
    d1 <- dplyr::filter(qonly, q==qvals[q1]) %>% select(., distance)
    d2 <- dplyr::filter(qonly, q==qvals[q2]) %>% select(., distance)
    temp <- data.frame(cor(d1,d2), qvals[q1],qvals[q2])
    qcors <- rbind(qcors, temp)
  }
}



v1 <- dplyr::filter(pcors, p==pvals[1]) %>% select(., distance)
v2 <- dplyr::filter(pcors, p==pvals[2]) %>% select(., distance)


ggplot(data = pcorsmall, aes(x=pvals.p1., y=pvals.p2., fill=distance)) + 
  geom_tile()+ggtitle("Correlation Between P Values (Q=1)")
```


```{r}
data(gene_edges)
use_data<-gene_edges
emb<-node2vecR(use_data,p=2,q=1,num_walks=5,walk_length=5,dim=10)
```

```{r}
#save(outlong, file="CoarseNode2VecGridBats.rda")
```

```{r}
library(word2vec)
library(udpipe)
## Take data and standardise it a bit
data(brussels_reviews, package = "udpipe")
x <- subset(brussels_reviews, language == "nl")
x <- tolower(x$feedback)

## Build the model get word embeddings and nearest neighbours
model <- word2vec(x = x, dim = 15, iter = 20)
emb   <- as.matrix(model)
head(emb)
emb <- predict(model, c("bus", "toilet", "unknownword"), type = "embedding")
emb
nn  <- predict(model, c("bus", "toilet"), type = "nearest", top_n = 5)
nn

class(model)
```

