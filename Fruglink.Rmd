---
title: "Frugivory"
author: "Grant Foster"
date: "9/9/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(magrittr)
library(igraph)
library(pROC)
library(BIEN)
library(np)
```


```{r read in data}
dat <- read.csv("Data.nosync/ATLANTIC_frugivory.csv")
```

```{r}
web <- dat %>% select(., Frugivore_Species, Plant_Species) %>% unique() %>% data.frame(
    from = uniq$Frugivore_Species,
    to = uniq$Plant_Species
  ) %>% graph_from_data_frame(directed=FALSE)

mat <-get.adjacency(web, type="both", sparse = FALSE)
isSymmetric.matrix(mat)

V(web)$type <- bipartite.mapping(web)$type
igraph::is.bipartite(web)

V(web)$color <-  NA
V(web)$color[V(web)$type==TRUE] <- "red"
V(web)$color[V(web)$type==FALSE] <- "blue"
```


```{r eval=FALSE}

plot(web, layout=layout_as_bipartite(web), edge.width=0.25, vertex.label=NA, vertex.size=1)


plot_data <- dat %>% mutate(
        to = factor(Plant_Species, levels = unique(c(dat$Plant_Species, dat$Frugivore_Species))),
        from = factor(Frugivore_Species, levels = unique(c(dat$Plant_Species, dat$Frugivore_Species))))

plot_data <- dat %>% mutate(
        to = factor(Plant_Species),
        from = factor(Frugivore_Species))

ggplot(plot_data, aes(x = from, y = to)) +
      geom_raster() +
      theme_bw() +
      # Because we need the x and y axis to display every node,
      # not just the nodes that have connections to each other,
      # make sure that ggplot does not drop unused factor levels
      scale_x_discrete(drop = FALSE) +
      scale_y_discrete(drop = FALSE) +
      theme(
        # Rotate the x-axis lables so they are legible
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        # Force the plot into a square aspect ratio
        aspect.ratio = 1,
        # Hide the legend (optional)
        legend.position = "none")
```
# I need a phylogeny for my species

The frugivore one I get from tree of life is ok, but the plant one kind of sucks-huge polytomies at really pretty high taxonomic levels. 


Let's get a better plant phylogeny than the one we're working with. 

```{r eval=FALSE}
plant_list <- unique(dat$Plant_Species)
plant_list <- gsub(" ","_", plant_list)

BIEN_tree <- BIEN_phylogeny_complete(n_phylogenies = 1, seed=1, replicates = 1)
BIEN_tree$tip.label

BIEN_matches <- plant_list[plant_list %in% BIEN_tree$tip.label==TRUE]

BIEN_subtree <- ape::keep.tip(BIEN_tree, tip=BIEN_matches)
pdf(file="BIEN_planttree.pdf")
plot(BIEN_subtree, show.tip.label=FALSE)
```

```{r eval=TRUE}
load("BIEN_subtree.Rda")
```

Now let's get a good frugivore phylogeny
```{r eval=FALSE}
Mammal_List <- filter(dat, Frug_Class=="Mammalia") %>% select(., Frugivore_Species) %>% unique()
Bird_List <- filter(dat, Frug_Class=="Aves") %>% select(., Frugivore_Species) %>% unique()

library(clipr)
clipr::write_clip(Mammal_List[,1]) #This way we can copy our species into the VertLife website to request a tree
clipr::write_clip(Bird_List[,1])
```

```{r eval=TRUE}
Mammal_trees <- ape::read.nexus(file="Data.nosync/VertLife_FrugMam/output.nex")

plot(Mammal_trees[1], show.tip.label = FALSE)

Mammal_List <- gsub(" ", "_", Mammal_List[,1])
Mammal_List[Mammal_List %in% Mammal_trees$tree_1642$tip.label==FALSE] #mammals not in our phylogeny

Bird_trees <- ape::read.nexus(file="Data.nosync/VertLife_FrugBird/output.nex")

plot(Bird_trees[1], show.tip.label = FALSE)

Bird_List <- gsub(" ", "_", Bird_List[,1])
Bird_List[Bird_List %in% Bird_trees$tree_2110$tip.label==FALSE] #mammals not in our phylogeny
```


```{r eval=FALSE}
pdf(file="Phylogenies.pdf", height=11, width=8.5)
par(mfrow = c(3, 2))
ape::plot.phylo(BIEN_subtree, show.tip.label = FALSE, type="fan", show.node.label = FALSE, main="Plants")
plot(BIEN_subtree, show.tip.label=FALSE)

ape::plot.phylo(Mammal_trees$tree_1642, show.tip.label = FALSE, type="fan", show.node.label = FALSE, main="Mammals")
plot(Mammal_trees$tree_1642, show.tip.label=FALSE)

ape::plot.phylo(Bird_trees$tree_2110, show.tip.label = FALSE, type="fan", show.node.label = FALSE, main="Birds")
plot(Bird_trees$tree_2110, show.tip.label=FALSE)
```

```{r}
dat %<>% filter(., Frugivore_Species != "Carollia castanea")
```


Subsampling our graph into training and test set. Deleting edges from our original graph lets us preserve our full adjacency matrix-if we take out entries from our dataframe instead we have problems later on in about predicting out of bounds. 

```{r}
set.seed(24601)

test_web <- igraph::delete.edges(web, sample(1:length(E(web)), 3658, replace = FALSE)) #remove 50% of our data
#plot(web, layout=layout_as_bipartite(web))
#plot(test_web, layout=layout_as_bipartite(test_web))

test_adj <- get.adjacency(test_web, type="both", sparse = FALSE)

#lattice::levelplot(test_adj)
isSymmetric.matrix(test_adj)
```

In order to get it working with plug and play, we need to turn our categorical variables into binary ones
```{r}

dat <- dplyr::filter_at(dat, vars(Plant_Form, Frugivory_score, Lipid_Score, Fruit_color, Plant_origin), all_vars(!is.na(.)))
dat %<>% dplyr::filter(., Fruit_color !="")
dat$Plant_origin[dat$Plant_origin !="native"] <- "nonnative"

dat$real <- 1

dat$Frugivory_score <- paste("FrugSc", dat$Frugivory_score, sep="")
dat$Lipid_Score <- paste("LipSc", dat$Lipid_Score, sep="")


categories <- list(Forms=unique(dat$Plant_Form),
                   Frugivory_score=unique(dat$Frugivory_score),
                   Lipid_Score=unique(dat$Lipid_Score),
                   Fruit_color=unique(dat$Fruit_color),
                   Plant_origin=unique(dat$Plant_origin)
                   )

dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Plant_Form, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Frugivory_score, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Lipid_Score, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Fruit_color, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Plant_origin, values_from = bin)

dat[, 32:ncol(dat)][is.na(dat[,32:ncol(dat)])==TRUE] <- 0 #Replae all NA's in our newly created columns with 0
#dat[, 32:ncol(dat)] <- dat[, 32:ncol(dat)]+1
```


Functionalizing Plug n Play
```{r}

pp.kde <- function(dat, FrugTraits, PlantTraits){
  #Set up our data into a fully expanded edgelist
  require(tidyr)
  dat$real <- 1
  dat <- dplyr::filter_at(dat, vars(c(FrugTraits, PlantTraits)), all_vars(!is.na(.)))
  full_L <- tidyr::expand(dat, Frugivore_Species, Plant_Species)
  full_real <- dplyr::select(dat, Frugivore_Species, Plant_Species, real) %>% left_join(full_L, ., by = c("Frugivore_Species", "Plant_Species")) #assigning real
  full_real$real[is.na(full_real$real)==TRUE] <- 0

  full_real_frugs <- dat[,c("Frugivore_Species", FrugTraits)] %>% unique() %>% left_join(full_real, ., by="Frugivore_Species")

  full_real_both <- dat[,c("Plant_Species", PlantTraits)] %>% unique() %>% left_join(full_real_frugs, ., by="Plant_Species")
  
  # Subsample our edgelist
  sample_IDs <- sample(round(nrow(full_real_both)*0.8), replace=F)
  test <- full_real_both[sample_IDs,]
  train <- full_real_both[-sample_IDs,]

  #set up our data to go into npudens
  p <- train[(train[,'real'] == 1), 4:ncol(train)] #positives cases
  bgrd <- train[,4:ncol(train)] #background (positive and negative) cases

  require(np)
  f1 <- np::npudens(p, bwmethod='cv.ml')
  f0 <- np::npudens(bgrd, bwmethod='normal-reference')
  model=list(f1, f0, test, train)
  names(model) <- c("f1", "f0", "test", "train")
  return(model)
}


class
z <-npudensbw(simple)

simple <- p[,c(1,9)]

?npudens

predict.pp.kde <- function(model, x){
  require(np)
  f1 <- fitted(npudens(bws = model$f1$bws, edat = x, bwmethod = 'normal-reference'))
  f0 <- fitted(npudens(bws = model$f0$bws, edat = x, bwmethod = 'normal-reference'))
  browser()
  return(S = f1/f0)
}

bats <- dplyr::filter(dat, Frug_Group=="Bats")

bats_kde <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size"), PlantTraits = c("fruit_diameter", "fruit_length"))

bats_pred <- predict.pp.kde(model=bats_kde, x=bats_kde$test[,4:7])
bats_kde$test$S <- bats_pred

test_results <- bats_kde$test
table(is.nan(out$S))
out %<>% filter(., is.nan(S)==FALSE)

out$S[is.infinite(out$S)] <- max(out$S[is.infinite(out$S)==FALSE], na.rm = TRUE)+1
AUC_test <- roc(data=out, response=real, predictor=S)
plot(AUC_test)
AUC_test
```

```{r}
bats_kde_long <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size", "FrugSc1", "FrugSc2", "FrugSc3"), PlantTraits = c("fruit_diameter", "fruit_length", "native", "nonnative", "liana", "tree", "epiphyte", "scrub", "palm", "herb", "Hemiparasita", "parasitic"))


test <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size"), PlantTraits = c("fruit_diameter", "fruit_length", categories$Forms))

bats_kde <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size", categories$Frugivory_score), PlantTraits = c("fruit_diameter", "fruit_length", categories$Forms, categories$Lipid_Score, categories$Fruit_color, categories$Plant_origin))
```



```{r}

pointsobject <- full_L %>% dplyr::select(., Frugivore_Species, Plant_Species, real, Frug_Mean_Gape_Size, Frug_Body_Mass, Frugivory_score, fruit_diameter, fruit_length, Fruit_color)

p <- pointsobject[(pointsobject[,'real'] == 1), 4:(ncol(pointsobject)-1)]
bgrd <- pointsobject[,4:(ncol(pointsobject)-1)]

#Recreating the plug and play approach

  mean.p <- colMeans(p, na.rm = TRUE)         # estimated mean of presence points
  mean.bgrd <- colMeans(bgrd)   # estimated mean of background points
  sigma.p <- stats::cov(p)             # estimated covariance of presence points
  sigma.bgrd <- stats::cov(bgrd)       # estimated covariance of background points
    
  
  require(corpcor)
    # robust estimated covariance of presence points
    p.est <- as.numeric(cov.shrink(p, verbose= TRUE))  
    sigma.p <- matrix(as.numeric(p.est), nrow=sqrt(length(p.est)))  #make it into a square matrix?
    # robust estimated covariance of background points
    bgrd.est <- as.numeric(cov.shrink(bgrd, verbose = TRUE))    
    sigma.bgrd <- matrix(as.numeric(bgrd.est), nrow=sqrt(length(bgrd.est))) # reformat

    model=list(mean.p=mean.p, sigma.p=sigma.p, mean.bgrd=mean.bgrd, sigma.bgrd=sigma.bgrd)  

    
predict.pp.gauss <- function(model, x){
  require(mvtnorm)
  f1 <- dmvnorm(x, mean=model$mean.p, sigma=model$sigma.p, log=TRUE)
  f0 <- dmvnorm(x, mean=model$mean.bgrd, sigma=model$sigma.bgrd, log=TRUE)
  return(S=exp(f1-f0))
} 

pp.kde <- function(p, bgrd){
  require(np)
  f1 <- npudens(p, bwmethod='normal-reference')
  f0 <- npudens(bgrd, bwmethod='normal-reference')
  return(model=list(f1=f1,f0=f0))
}

predict.pp.kde <- function(model, x){
  require(np)
  f1 <- fitted(npudens(bws=model$f1$bws, edat=data.frame(x), bwmethod='normal-reference'))
  f0 <- fitted(npudens(bws=model$f0$bws, edat=data.frame(x), bwmethod='normal-reference'))
  return(S=f1/f0)
}


red.preds.gauss <- predict.pp.gauss(model, x=bgrd)
full_L$suit.gauss <- red.preds.gauss

stuff <- pp.kde(p, bgrd)

str(stuff)
red.preds.kde <- predict.pp.kde(stuff, bgrd)


full_L$suit.kde <- red.preds.kde

AUC_PP <- roc(data=data.frame(full_L), response=real, predictor=suit)
AUC_PP
plot(AUC_PP)
```
Simplifying the problem: for both complexity and runtime's sake
Note:frugivory is not actually meaningful, but it's still in. 

14 bat species, 47 plant species.
```{r}
#Make long form of just bat intearactions.
bats <- dplyr::filter(dat, Frug_Group=="Bats")
batsL <- tidyr::expand(bats, Frugivore_Species, Plant_Species)

#Left_Join in our trait data and denote real entries
batsL <-  bats %>% select(., Frugivore_Species, Frug_Mean_Gape_Size, Frug_Body_Mass) %>% unique() %>% left_join(batsL, ., by="Frugivore_Species")
batsL <-  dat %>% select(., Plant_Species, fruit_diameter, fruit_length) %>% unique() %>% left_join(batsL, ., by="Plant_Species")
batsL <- bats %>% select(., Frugivore_Species, Plant_Species) %>% mutate(., real=1) %>% left_join(batsL, ., by=c("Frugivore_Species", "Plant_Species"))
batsL$real[is.na(batsL$real)==TRUE] <- 0

batsL %<>% filter(., Frugivore_Species != "Carollia castanea") #wrong gape size

#Sample our overall data
batsL_sample <- batsL[sample(nrow(batsL)/2, replace=T),]



p <- batsL_sample[batsL_sample$real ==1,3:(ncol(batsL_sample)-1)]
bgrd <- batsL_sample[,3:(ncol(batsL_sample)-1)]

mean.p <- colMeans(p, na.rm = TRUE)         # estimated mean of presence points
mean.bgrd <- colMeans(bgrd)   # estimated mean of background points
sigma.p <- stats::cov(p)             # estimated covariance of presence points
sigma.bgrd <- stats::cov(bgrd)

batsL[,3:(ncol(batsL_sample)-1)]

require(np)

p[,-c(8,)]
f1 <- npudensbw(p, bwmethod='normal-reference')
f0 <- npudensbw(bgrd, bwmethod='normal-reference')
  

f1_fit <- fitted(npudens(bws=f1, edat=birdsL[,3:(ncol(birdsL_sample)-1)], bwmethod='normal-reference'))
f0_fit <- fitted(npudens(bws=f0, edat=birdsL[,3:(ncol(birdsL_sample)-1)], bwmethod='normal-reference'))


f1_fit <- fitted(npudens(bws=f1, edat=batsL[,3:(ncol(batsL_sample)-1)], bwmethod='normal-reference'))
f0_fit<- fitted(npudens(bws=f0, edat=batsL[,3:(ncol(batsL_sample)-1)], bwmethod='normal-reference'))

S <- f1_fit/f0_fit

batsL$S <- S

AUC_PP_Traits_Bats <- roc(data=batsL, response=real, predictor=S)
plot(AUC_PP_Traits_Bats)
AUC_PP_Bats
```

```{r}
#Make long form of just bat intearactions.
birds <- dplyr::filter(dat, Frug_Class=="Aves")
birdsL <- tidyr::expand(birds, Frugivore_Species, Plant_Species)

#Left_Join in our trait data and denote real entries
birdsL <-  birds %>% select(., Frugivore_Species, Frug_Mean_Gape_Size, Frug_Body_Mass) %>% unique() %>% left_join(birdsL, ., by="Frugivore_Species")
birdsL <-  dat %>% select(., Plant_Species, fruit_diameter, fruit_length) %>% unique() %>% left_join(birdsL, ., by="Plant_Species")
birdsL <- birds %>% select(., Frugivore_Species, Plant_Species) %>% mutate(., real=1) %>% left_join(birdsL, ., by=c("Frugivore_Species", "Plant_Species"))
birdsL$real[is.na(birdsL$real)==TRUE] <- 0

birdsL %<>% filter(., Frugivore_Species != "Carollia castanea") #wrong gape size

#Sample our overall data
birdsL_sample <- birdsL[sample(nrow(birdsL)/2, replace=T),]



p <- birdsL_sample[birdsL_sample$real ==1,3:(ncol(birdsL_sample)-1)]
bgrd <- birdsL_sample[,3:(ncol(birdsL_sample)-1)]

mean.p <- colMeans(p, na.rm = TRUE)         # estimated mean of presence points
mean.bgrd <- colMeans(bgrd)   # estimated mean of background points
sigma.p <- stats::cov(p)             # estimated covariance of presence points
sigma.bgrd <- stats::cov(bgrd)

birdsL[,3:(ncol(birdsL_sample)-1)]

require(np)
f1 <- npudensbw(p, bwmethod='normal-reference')
f0 <- npudensbw(bgrd, bwmethod='normal-reference')


bandwidths <- npudensbw(p[,-c(8,13,14,15,28)], bwmethod='cv.ml')
  
f1_fit <- fitted(npudens(bws=f1, edat=birdsL[,3:(ncol(birdsL_sample)-1)], bwmethod='normal-reference'))
f0_fit <- fitted(npudens(bws=f0, edat=birdsL[,3:(ncol(birdsL_sample)-1)], bwmethod='normal-reference'))

S <- f1_fit/f0_fit


birdsL$S <- S
birdsL <- birdsL[is.na(birdsL$S)==FALSE,]
birdsL$S[birdsL$S==Inf] <- max(birdsL$S[birdsL$S!=Inf], na.rm=TRUE)+1

AUC_PP_Traits_birds <- roc(data=birdsL, response=real, predictor=S)
plot(AUC_PP_Traits_birds)
AUC_PP_Traits_birds
```

Alright; now that plug and play works for host and plant traits let's add in phylogeny. 

I set all branch lengths to 1 and then force it back to being ultrametric. This feels like bad juju.
```{r}
library(PVR)
library(ape)
library(phytools)

plant_tree <- ape::compute.brlen(plant_tree, 1) #set branch lengths to 1
plant_tree <- phytools::force.ultrametric(plant_tree) #force back to being ultrametric (may be bad)
plant_litter <- PVR::PVRdecomp(phy=plant_tree, type="newick", scale=TRUE)

round((plant_litter@Eigen$values)/sum((plant_litter@Eigen$values)),3)*100 #first three vectors only contain about 28% of variation :(

plant_PhyEig <-data.frame(plant_tree$tip.label, plant_litter@Eigen$vectors[,1:3])

plant_PhyEig %<>% rename(., "Plant_Species"=plant_tree.tip.label)
plant_PhyEig$Plant_Species <- gsub("_ott.*","", x=plant_PhyEig$Plant_Species)
plant_PhyEig$Plant_Species <- gsub(pattern="_", replace=" ", x=plant_PhyEig$Plant_Species)

dat <- left_join(dat, plant_PhyEig, by="Plant_Species")

frug_tree <- ape::compute.brlen(frug_tree, 1) #set branch lengths to 1
frug_tree <- phytools::force.ultrametric(frug_tree) #force back to being ultrametric (may be bad)
frug_litter <- PVR::PVRdecomp(phy=frug_tree, type="newick", scale=TRUE)

round((frug_litter@Eigen$values)/sum((frug_litter@Eigen$values)),3)*100 #first three vectors contain about 33.8% of variation

frug_PhyEig <-data.frame(frug_tree$tip.label, frug_litter@Eigen$vectors[,1:3])

frug_PhyEig %<>% rename(., "Frugivore_Species"=frug_tree.tip.label)
frug_PhyEig$Frugivore_Species <- gsub("_ott.*","", x=frug_PhyEig$Frugivore_Species)
frug_PhyEig$Frugivore_Species <- gsub(pattern="_", replace=" ", x=frug_PhyEig$Frugivore_Species)
colnames(frug_PhyEig) <- c("Frugivore_Species", "fc1", "fc2", "fc3")

dat <- left_join(dat, frug_PhyEig, by="Frugivore_Species")
```



```{r}
#Make long form of just bat intearactions.
bats <- dplyr::filter(dat, Frug_Group=="Bats")
batsL <- tidyr::expand(bats, Frugivore_Species, Plant_Species)

#Left_Join in our trait data and denote real entries
batsL <-  bats %>% select(., Frugivore_Species, fc1, fc2, fc3) %>% unique() %>% left_join(batsL, ., by="Frugivore_Species")
batsL <-  dat %>% select(., Plant_Species, c1, c2, c3) %>% unique() %>% left_join(batsL, ., by="Plant_Species")
batsL <- bats %>% select(., Frugivore_Species, Plant_Species) %>% mutate(., real=1) %>% left_join(batsL, ., by=c("Frugivore_Species", "Plant_Species"))

batsL$real[is.na(batsL$real)==TRUE] <- 0

batsL %<>% filter(., Frugivore_Species != "Carollia castanea") #wrong gape size
batsL %<>% filter(., is.na(c1)==FALSE)
batsL %<>% filter(., is.na(fc1)==FALSE)

#Sample our overall data
batsL_sample <- batsL[sample(nrow(batsL)/2, replace=T),]


p <- batsL_sample[batsL_sample$real ==1,3:(ncol(batsL_sample)-1)]
bgrd <- batsL_sample[,3:(ncol(batsL_sample)-1)]

mean.p <- colMeans(p, na.rm = TRUE)         # estimated mean of presence points
mean.bgrd <- colMeans(bgrd)   # estimated mean of background points
sigma.p <- stats::cov(p)             # estimated covariance of presence points
sigma.bgrd <- stats::cov(bgrd)


require(np)
f1 <- npudensbw(p, bwmethod='normal-reference')
f0 <- npudensbw(bgrd, bwmethod='normal-reference')
  
f1_fit <- fitted(npudens(bws=f1, edat=batsL[,3:(ncol(batsL_sample)-1)], bwmethod='normal-reference'))
f0_fit<- fitted(npudens(bws=f0, edat=batsL[,3:(ncol(batsL_sample)-1)], bwmethod='normal-reference'))

S <- f1_fit/f0_fit

batsL$S <- S

AUC_PP_Phylo_Bats <- roc(data=batsL, response=real, predictor=S)
plot(AUC_PP_Phylo_Bats)
AUC_PP_Phylo_Bats
```
```{r}
#Make long form of just bat intearactions.
birds <- dplyr::filter(dat, Frug_Class=="Aves")
birdsL <- tidyr::expand(birds, Frugivore_Species, Plant_Species)

#Left_Join in our trait data and denote real entries
birdsL <-  birds %>% select(., Frugivore_Species, fc1, fc2, fc3) %>% unique() %>% left_join(birdsL, ., by="Frugivore_Species")
birdsL <-  dat %>% select(., Plant_Species, c1, c2, c3) %>% unique() %>% left_join(birdsL, ., by="Plant_Species")
birdsL <- birds %>% select(., Frugivore_Species, Plant_Species) %>% mutate(., real=1) %>% left_join(birdsL, ., by=c("Frugivore_Species", "Plant_Species"))

birdsL$real[is.na(birdsL$real)==TRUE] <- 0

birdsL %<>% filter(., Frugivore_Species != "Carollia castanea") #wrong gape size
birdsL %<>% filter(., is.na(c1)==FALSE)
birdsL %<>% filter(., is.na(fc1)==FALSE)

#Sample our overall data
birdsL_sample <- birdsL[sample(nrow(birdsL)/2, replace=T),]


p <- birdsL_sample[birdsL_sample$real ==1,3:(ncol(birdsL_sample)-1)]
bgrd <- birdsL_sample[,3:(ncol(birdsL_sample)-1)]

mean.p <- colMeans(p, na.rm = TRUE)         # estimated mean of presence points
mean.bgrd <- colMeans(bgrd)   # estimated mean of background points
sigma.p <- stats::cov(p)             # estimated covariance of presence points
sigma.bgrd <- stats::cov(bgrd)


require(np)
f1 <- npudensbw(p, bwmethod='normal-reference')
f0 <- npudensbw(bgrd, bwmethod='normal-reference')
  
f1_fit <- fitted(npudens(bws=f1, edat=birdsL[,3:(ncol(birdsL_sample)-1)], bwmethod='normal-reference'))
f0_fit<- fitted(npudens(bws=f0, edat=birdsL[,3:(ncol(birdsL_sample)-1)], bwmethod='normal-reference'))

S <- f1_fit/f0_fit

birdsL$S <- S

AUC_PP_Phylo_birds <- roc(data=birdsL, response=real, predictor=S)
plot(AUC_PP_Phylo_birds)
AUC_PP_Phylo_birds
```


```{r}
pdf(file="PlugPlayTestAUC.pdf", height = 8.5, width=11)
par(mfrow=c(2,2))
plot(AUC_PP_Traits_Bats, main="Plug & Play Trait AUC; Bats")
mtext("AUC=0.7621", side=1)
plot(AUC_PP_Phylo_Bats, main="Plug & Play PhyloDecomposition AUC; Bats")
mtext("AUC=0.8211", side=1)
plot(AUC_PP_Traits_birds, main="Plug & Play Trait AUC; Birds")
mtext("AUC=0.6782", side=1)
plot(AUC_PP_Phylo_birds, main="Plug & Play PhyloDecomposition AUC; Birds")
mtext("AUC=0.6009", side=1)

#Plants: 28%, animals 33.8% of variation  
```

### Below here is scratch work-not analysis!
Creating link prediction function

Note: If I make a strictly upper triangular matrix (non-symmetric), it's eigenvalues will all be 0. So we need to see a symmetric matrix. 

We want ideally to minimize the Sigma[f(delta_kk)-U^T * A' * Uk]^2, essentially a sum of squares.
```{r}
U <-eigen(mat)$vectors
L <- eigen(mat)$values
table(mat)
table(mat)/sum(table(mat))


# A = U*L*U^T
test <- U %*% diag(L) %*% t(U)
test <- round(test, digits=3) #Rounding errors make our 0's into super small values
table(test==mat) #This should be true

#A' = F(A) = U*F(L)*U^T, where F is our kernel function relating our training set (A) to test set (A')
#We want to minimize |F(A)-A'|, where

U_train <- eigen(test_adj)$vectors
L_train <- eigen(test_adj)$values

target_V <- t(U_train) %*% mat %*% U_train
target_V <- diag(target_V)

plot(x=L_train, y=target_V, col="dodger blue", pch=16)
```

The first kernel that we use is odd path counting. Here we look at weighted sum of several odd powers of the original adjacency matrix (recall that k-th power of an adjacency matrix refers to numbers of k-hop neighbours from every node). The higher the value, the more likely it is for two vertices to be connected.

I think this is mostly wrong. I hope to fix it in the future.

```{r}
library(expm)

odd_kernal <- function(input, max_path){
  index <- seq(from=1, to=max_path, by=2)
  #index <- index[-1]
  output <- 0
  for(i in index){
    #print(i)
    output <- output + (test_adj %^% i)
  }
  return(output)
}

odd_paths_V1 <- t(U_train) %*% odd_kernal(input=test_adj, max_path = 1) %*% U_train
odd_paths_pred1 <- diag(odd_paths_V1)

odd_paths_V3 <- t(U_train) %*% odd_kernal(input=test_adj, max_path = 3) %*% U_train
odd_paths_pred3 <- diag(odd_paths_V3)

odd_paths_V5 <- t(U_train) %*% odd_kernal(input=test_adj, max_path = 5) %*% U_train
odd_paths_pred5 <- diag(odd_paths_V5)

odd_paths_V7 <- t(U_train) %*% odd_kernal(input=test_adj, max_path = 7) %*% U_train
odd_paths_pred7 <- diag(odd_paths_V7)

odd_paths_V9 <- t(U_train) %*% odd_kernal(input=test_adj, max_path = 9) %*% U_train
odd_paths_pred9 <- diag(odd_paths_V9)

plot(x=L_train, y=target_V, col="dodger blue", pch=16)
points(x=L_train, y=odd_paths_pred1, col="red", pch=16)
points(x=L_train, y=odd_paths_pred3, col="orange", pch=16)
points(x=L_train, y=odd_paths_pred5, col="green", pch=16)
points(x=L_train, y=odd_paths_pred7, col="purple", pch=16)
points(x=L_train, y=odd_paths_pred9, col="navy", pch=16)
legend(1, 1, legend=c("1 (base)", "3", "5", "7", "9"),
       col=c("red", "orange", "green", "purple", "navy"), pch=16, cex=0.8)

all.equal(dim(odd_paths_V1), dim(mat))

edgelist <- data.frame(matrix(mat, dimnames=list(t(outer(colnames(mat), rownames(mat), FUN=paste)), NULL)))
colnames(edgelist) <- "truth"
edgelist <- rownames_to_column(edgelist, var="link")


colnames(odd_paths_V1) <- colnames(mat)
rownames(odd_paths_V1) <- rownames(mat)
odd_paths_1L <- data.frame(matrix(odd_paths_V1, dimnames=list(t(outer(colnames(odd_paths_V1), rownames(odd_paths_V1), FUN=paste)), NULL)))
colnames(odd_paths_1L) <- "Path1"
odd_paths_1L <- rownames_to_column(odd_paths_1L, var="link")

colnames(odd_paths_V3) <- colnames(mat)
rownames(odd_paths_V3) <- rownames(mat)
odd_paths_3L <- data.frame(matrix(odd_paths_V3, dimnames=list(t(outer(colnames(odd_paths_V3), rownames(odd_paths_V3), FUN=paste)), NULL)))
colnames(odd_paths_3L) <- "Path3"
odd_paths_3L <- rownames_to_column(odd_paths_3L, var="link")

ROC_data <- left_join(edgelist, odd_paths_1L, by="link")
ROC_data <- left_join(ROC_data, odd_paths_3L, by="link")

simple_roc <- function(labels, scores){
  labels <- labels[order(scores, decreasing=TRUE)]
  data.frame(TPR=cumsum(labels)/sum(labels), FPR=cumsum(!labels)/sum(!labels), labels)
}

temp <- simple_roc(labels=ROC_data$truth, scores=ROC_data$Path1)
temp2 <- simple_roc(labels=ROC_data$truth, scores=ROC_data$Path3)
plot(x=temp$FPR, y=temp$TPR, type="l", col="blue")
lines(x=temp2$FPR, y=temp2$TPR, type="l", col="red")


AUC_Odd1 <- roc(response=ROC_data$truth, predictor=ROC_data$Path1)
AUC_Odd3 <- roc(response=ROC_data$truth, predictor=ROC_data$Path3)

auc(AUC_Odd1)
plot(AUC_Odd1)

auc(AUC_Odd3)
plot(AUC_Odd3)
```


Let's get a better plant phylogeny than the one we're working with. 

```{r}
library(BIEN)
length(unique(dat$Plant_Species))
plant_list <- unique(dat$Plant_Species)
plant_list <- gsub(" ","_", plant_list)

BIEN_tree <- BIEN_phylogeny_complete(n_phylogenies = 1, seed=1, replicates = 1)
BIEN_tree$tip.label

BIEN_matches <- plant_list[plant_list %in% BIEN_tree$tip.label==TRUE]

temp <- BIEN_tree
BIEN_subtree <- ape::keep.tip(temp, tip=BIEN_matches)
pdf(file="BIEN_planttree.pdf")
plot(BIEN_subtree, show.tip.label=FALSE)

load("BIEN_subtree.Rda")
```

