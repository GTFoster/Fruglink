---
title: "Supplemental Analysis"
author: "ANONYMIZED"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60), tidy=TRUE, warning = FALSE, message=FALSE)
```

```{r, quiet=TRUE, message=FALSE, echo=FALSE}
library(tidyverse)
library(igraph)
library(BIEN)
library(PVR)
library(ape)
library("phytools")
library(picante)
library(magrittr)
library(kableExtra)
library(pROC)
library(magrittr)
library(tictoc)

```

```{r, echo=FALSE}
#Initial data processing steps
dat <- read.csv("../Data.nosync/DataSources/ATLANTIC_frugivory.csv")
dat %<>% dplyr::filter(., Frugivore_Species != "Carollia castanea") #This bat has an incorrect gape size, so it's filtered out
dat <- dplyr::select(dat, -ID, -Latitude, -Longitude, -Study_Location, -Precision, -Study_Method, -Study.reference, -Doi.Link, -Frug_Population_Trend, -Frug_Migration_status)
dat %<>% unique(.)
birds <- dplyr::filter(dat, Frug_Class=="Aves")
```

## Phylogenetic Specialism

Here we quantify the phylogenetic specialism of frugivores. To do this, we'll employ the `ses.mpd()` from the `picante` library. This function allows us to use a null model of our choice to find the standard effect size of pairwise distance in communities. In our case, we're interested in pairwise mean phylogenetic distance, and our "communities" are the total sets of plants that each frugivore interact with. We employ an independent swap null model, where the tip labels of the underlying phylogenetic tree are effectively swapped a given number of times (Gotelli, 2000). 

```{r, tidy=TRUE}
set.seed(1)
load("../Data.nosync/DataSources/BIEN_subtree.Rda")
#Create cophenetic distance matrix
dmatrix <- stats::cophenetic(BIEN_subtree) 
#Standardize by the maximum value
dmatrix <- dmatrix/max(dmatrix) 

#String manipulation so tree tip names match
birds$plant_Tips <- gsub(pattern=" ", replace="_", x=birds$Plant_Species) 
#Only include plant species for which phylogenetic info is available
birds_phylo<- dplyr::filter(birds, plant_Tips %in% BIEN_subtree$tip.label) 

comm <- as.data.frame.matrix(table(birds_phylo$Frugivore_Species, birds_phylo$plant_Tips))#Binary, unweighted intraction matrix.
#The main function. Randomly swap tip labels 999 times and see whether the observed sets of plant interactors for each species is more phylogenetically clustered than this assumed distribution
test_mpd <- picante::ses.mpd(comm, dmatrix, null.model = "independentswap", abundance.weighted=FALSE, runs = 999, iterations = 1000) 
 #Remove singleton species (can't compute a phylogenetic distance)
phylospec <- dplyr::filter(test_mpd, ntaxa > 1)
 #Remove singleton species (can't compute a phylogenetic distance)
sig <- nrow(dplyr::filter(phylospec, mpd.obs.p<0.05)) 
print(sig)
```

We see that the number of frugivores whose plant partners are more significantly related than expected compared to a random draw is equal to `r sig` (The exact value may change slightly when the seed is changed due to the stochastic nature of the model, but the results should be qualitatively similar each time)

## Calculating the number of unique species in the dataset
```{r, echo=FALSE}
#Number of unique species and interactions

#For the full dataset
#length(unique(dat$Frugivore_Species))
#length(unique(dat$Plant_Species))

```



In our dataset, we observe interactions between `r length(unique(birds$Frugivore_Species))` unique frugivore species and `r length(unique(birds$Plant_Species))` unique plant species.

## Degree Distributions of Mutualistic Partners

```{r, echo=FALSE, fig.width=5, fig.height=4}
#paste(median(table(dat$Frugivore_Species)),"=median frugivore degree", sep=" ")
hist(table(birds$Frugivore_Species), xlab="Degree", ylab="Observed Frequency", main=NA)
#frugdeg <- dplyr::group_by(birds, Frugivore_Species) %>% dplyr::summarise(., degree=length(unique(Plant_Species)))
#frugdeg$Frugivore_Species[frugdeg$degree==max(frugdeg$degree)]
#range(frugdeg$degree)
#table(table(birds$Frugivore_Species)==1) #Singleton species
```


**Figure S1:** Observed degree distribution of avian frugivore species included in our analyses. X-axis represents node degree, or number of unique partners. Degree for frugivores ranged from 1 (53 species) to 120 unique plant interactions recorded for \emph{Turdus rufiventris}; median frugivore degree was `r median(table(dat$Frugivore_Species))`.

```{r, echo=FALSE, fig.width=5, fig.height=4}
#paste(median(table(dat$Plant_Species)),"= median plant degree", sep=" ")
hist(table(birds$Plant_Species), xlab="Degree", ylab="Observed Frequency", main=NA)
#plantdeg <- dplyr::group_by(birds, Plant_Species) %>% dplyr::summarise(., degree=length(unique(Frugivore_Species)))
#plantdeg$Plant_Species[plantdeg$degree==max(plantdeg$degree)]
#range(plantdeg$degree)
#table(table(birds$Plant_Species)==1) #Singleton species
```


**Figure S2:** Observed degree distribution of plant species included in our analyses. X-axis represents node degree, or number of unique partners. Degree on average tended to be lower for plants than frugivores; plant node degree ranged from 1 (128 species) to 80 unique frugivorous interactions recorded for \emph{Myrsine coriacea}; median plant degree was `r median(table(dat$Frugivore_Species))`.

```{r, echo=FALSE}
Bird_trees <- ape::read.nexus("../Data.nosync/DataSources/VertLife_FrugBird/query2/output_larger.nex")

    nas <- birds[gsub(" ", "_", birds$Frugivore_Species) %in%  Bird_trees[[round(1)]]$tip.label==FALSE,] %>% dplyr::select(., Frugivore_Species)  %>% unique() #Extract Bird taxa that don't occur in our tree
    genera <- sub("_[^ ]+$", "", Bird_trees[[round(1)]]$tip.label) %>% unique() #Genera list present in our bird tree
    nas$genus <- sub(" [^ ]+$", "", nas$Frugivore_Species) #Extract only genera of the nas
    nas <- nas[nas$genus %in% genera,] #Remove species without congeneric already in the tree
    nas <- nas[grepl(" ", nas$Frugivore_Species)==TRUE,] #Remove interactions only assigned to the genus level-this leaves just 1 warbler species
    ult_birdTree <- force.ultrametric(Bird_trees[[round(1)]], message=F) #Our tree should already be ultrametric, but just in case
    polytree <- ult_birdTree #new tree object
    for(j in 1:nrow(nas)){ #add in our missing genera as polytomies
      polytree <- phytools::add.species.to.genus(tree=polytree, species=nas$Frugivore_Species[j], where="root") #Create polytomy at the genera root. 
    }
    #length(polytree$tip.label) - length(ult_birdTree$tip.label) #Number of net gained tips
  
  #Set up Phylogeny
  frug_litter <- PVR::PVRdecomp(phy=polytree, type="newick", scale=TRUE)
  frug_PhyEig <-data.frame(polytree$tip.label, frug_litter@Eigen$vectors[,1:3]) #take first three vectors and make them a dataframe
  colnames(frug_PhyEig) <- c("Frugivore_Species", "fc1", "fc2", "fc3")
  frug_PhyEig$Frugivore_Species <- gsub(pattern="_", replace=" ", x=frug_PhyEig$Frugivore_Species) 
  birds_temp <- left_join(birds, frug_PhyEig, by="Frugivore_Species") #Make a new object that includes our phylo information

svData <- function(dat){
mat_assym <- as.data.frame.matrix(table(dat$Frugivore_Species, dat$Plant_Species)) #Rows = Frugivores, Columns = Plants

decomp <- svd(mat_assym)#run svd decomposition
u <- decomp$u #extract first 3 axis
v <- data.frame(decomp$v) #I think this is the right dimension?

plantsSVD <-data.frame(colnames(mat_assym), v[,1], v[,2], v[,3])
colnames(plantsSVD) <- c("Plant_Species", "Psvd1", "Psvd2", "Psvd3")
frugSVD <- data.frame(colnames(t(mat_assym)), u[,1], u[,2], u[,3])
colnames(frugSVD) <- c("Frugivore_Species", "Fsvd1", "Fsvd2", "Fsvd3")

dat_wP <- left_join(dat, plantsSVD, by="Plant_Species")
dat_new <- left_join(dat_wP, frugSVD, by="Frugivore_Species")

return(dat_new)
}


birds_temp <- svData(birds_temp) #Add in SVD


load("../Data.nosync/DataSources/BIEN_subtree.Rda") #load in plant tree
plant_litter <- PVR::PVRdecomp(phy=BIEN_subtree, type="newick", scale=TRUE)

sum((round((plant_litter@Eigen$values)/sum((plant_litter@Eigen$values)),3)*100)[1:4]) #first three vectors contain about 37.5% of variation

plant_PhyEig <-data.frame(BIEN_subtree$tip.label, plant_litter@Eigen$vectors[,1:5])
colnames(plant_PhyEig) <- c("Plant_Species", paste(colnames(plant_PhyEig)[2:ncol(plant_PhyEig)], "PlDecomp", sep=""))

plant_PhyEig$Plant_Species <- gsub(pattern="_", replace=" ", x=plant_PhyEig$Plant_Species)

birds_temp <- left_join(birds_temp, plant_PhyEig, by="Plant_Species")
```

```{r, echo=FALSE}
p_phylo <- c("c1PlDecomp", "c2PlDecomp", "c3PlDecomp", "c4PlDecomp")
p_traits <- c("fruit_diameter", "Fruit_color", "Plant_Form", "Lipid_Score")
p_latent <- c("Psvd1", "Psvd2", "Psvd3")

f_phylo <- c("fc1", "fc2", "fc3")
f_traits <- c("Frug_Body_Mass","Frug_Mean_Gape_Size", "Frugivory_score")
f_latent <- c("Fsvd1", "Fsvd2", "Fsvd3")


counTable <- data.frame(model=c("Latent", "Phy", "Traits", "PhyLatent", "PhyTraits", "TraitsLatent", "Trio"), 
           nlinks=c(
             nrow(dplyr::filter_at(birds_temp, vars(c(p_latent, f_latent)), all_vars(!is.na(.)))), #latent
            nrow(dplyr::filter_at(birds_temp, vars(c(p_phylo, f_phylo)), all_vars(!is.na(.)))), #phy
             nrow(dplyr::filter_at(birds_temp, vars(c(p_traits, f_traits)), all_vars(!is.na(.)))), #traits
             nrow(dplyr::filter_at(birds_temp, vars(c(p_phylo, p_latent, f_phylo, f_latent)), all_vars(!is.na(.)))),
             nrow(dplyr::filter_at(birds_temp, vars(c(p_phylo, p_traits, f_phylo, f_traits)), all_vars(!is.na(.)))),
             nrow(dplyr::filter_at(birds_temp, vars(c(p_latent, p_traits, f_traits, f_latent)), all_vars(!is.na(.)))),
             
             nrow(dplyr::filter_at(birds_temp, vars(c(p_latent, p_traits, p_phylo, f_phylo, f_latent, f_traits)), all_vars(!is.na(.))))
           ), 
           nfrug=c( ###Defining Frugivores
             length(unique(dplyr::filter_at(birds_temp, vars(c(p_latent, f_latent)), all_vars(!is.na(.)))$Frugivore_Species)), #latent
            length(unique(dplyr::filter_at(birds_temp, vars(c(p_phylo, f_phylo)), all_vars(!is.na(.)))$Frugivore_Species)), #phy
             length(unique(dplyr::filter_at(birds_temp, vars(c(p_traits, f_traits)), all_vars(!is.na(.)))$Frugivore_Species)), #traits
             length(unique(dplyr::filter_at(birds_temp, vars(c(p_phylo, p_latent, f_phylo, f_latent)), all_vars(!is.na(.)))$Frugivore_Species)),
             length(unique(dplyr::filter_at(birds_temp, vars(c(p_phylo, p_traits, f_phylo, f_traits)), all_vars(!is.na(.)))$Frugivore_Species)),
             length(unique(dplyr::filter_at(birds_temp, vars(c(p_latent, p_traits, f_traits, f_latent)), all_vars(!is.na(.)))$Frugivore_Species)),
             
             length(unique(dplyr::filter_at(birds_temp, vars(c(p_latent, p_traits, p_phylo, f_phylo, f_latent, f_traits)), all_vars(!is.na(.)))$Frugivore_Species))
           ), 
           nplants=c( ###Defining Frugivores
             length(unique(dplyr::filter_at(birds_temp, vars(c(p_latent, f_latent)), all_vars(!is.na(.)))$Plant_Species)), #latent
            length(unique(dplyr::filter_at(birds_temp, vars(c(p_phylo, f_phylo)), all_vars(!is.na(.)))$Plant_Species)), #phy
             length(unique(dplyr::filter_at(birds_temp, vars(c(p_traits, f_traits)), all_vars(!is.na(.)))$Plant_Species)), #traits
             length(unique(dplyr::filter_at(birds_temp, vars(c(p_phylo, p_latent, f_phylo, f_latent)), all_vars(!is.na(.)))$Plant_Species)),
             length(unique(dplyr::filter_at(birds_temp, vars(c(p_phylo, p_traits, f_phylo, f_traits)), all_vars(!is.na(.)))$Plant_Species)),
             length(unique(dplyr::filter_at(birds_temp, vars(c(p_latent, p_traits, f_traits, f_latent)), all_vars(!is.na(.)))$Plant_Species)),
             
             length(unique(dplyr::filter_at(birds_temp, vars(c(p_latent, p_traits, p_phylo, f_phylo, f_latent, f_traits)), all_vars(!is.na(.)))$Plant_Species))
           ))
```
**Table S1:** Number of interactions, unique bird species, and unique plant species used in each model. Incomplete modeling cases were dropped from each model; the remaining number of complete cases was shown below. 
```{r}
kable(counTable, col.names = c("Model", "Number of Links", "Number of Bird species", "Number of Plant spp"))
```

## Impact of Phylogenetic Imputation
In our main text results, for the 46 plant species and 2 bird species which did not appear in the appropriate phylogenies but did have congenerics, we randomly assigned those species to be a polytomy within their parent genera. When these species are excluded from the analysis, our results are still qualitatively indistinguishable. Below are versions of the three main-text figures with those 48 species removed from the network. 

![]("fig1_nopoly_col2.pdf")

**Figure S3:** Summary performance metrics of all 7 models *when species without full phylogenetic information are excluded*, as measured by area under the receiver operating characteristic curve (AUC) and root mean squared error (RMSE); highest performing models for each metric are outlined in black. Mean metric values are presented from 100 replicates of each model structure alongside standard deviation. As in the main text, model discriminatory power between links and non-links is maximized by including latent structural features, with the inclusion of trait, phylogenetic information, or both actually slightly decreasing discriminatory power. However, inclusion of trait and phylogenetic information, while not improving AUC, does increase overall model accuracy as measured by mean root squared error.



![]("fig2_nopoly_col2.pdf")

**Figure S4:** Variable importance across all models as measure by Gini importance score *when species without full phylogenetic information are excluded*; color scheme is consistent with figure S3. As in the maintext,latent traits were consistently the most important variables for prediction. These were followed by continuous frugivore traits (body mass, gape size), and frugivore phylogenetic axes. Plant phylogenies and continuous trait information were generally less important for prediction than frugivore traits. Categorical plant traits (Lipid content, fruit color, growth form) were the least important variables for prediction.

![]("fig3_nopoly.pdf")

**Figure S4:** Pairwise Spearman's rank correlations of link suitabilities across models for all potential interaction (A), as well as only unobserved interactions (B), *after species without full phylogenetic information are excluded*. The latter set of links represents both true forbidden links, as well as other potential interactions not observed in our data-set.



### Sensitivity to Class Imbalances
In order to deal with the high degree of sparceness in our network, we trim the training set to enforce class balancing. In the maintext, we present the results of a 3:1 ratio unobserved:observed links. Here, show the methods is relatively insensitive to this exact proportion by repeating our analysis with alternative training ratios of 1:1 and 1:10.

![](suitability_comp_unscaled.pdf)

**Figure S5:** Scatterplot of relative suitability values of the same models trained under either a 1:3 ratio of present to absent interactions (y-axis) or a 1:1 ratio (x-axis); red dashed lines represent a 1:1 line. While the absolute value of suitability values tend to be reduced when the prevalence of true positives is reduced (most points fall below the 1:1 line), the relative rank of suitability values tends is very closely aligned (Spearman's $\rho = 0.964$ across all predictions).

![](AUC_Ratio.pdf)

**Figure S6:** Box plots of AUC values for model predictions on a 20% test set after being conditioned on training data with either 1:1, 1:3, or 1:10 ratios of presence to absence values. We see that while there is some variation in model performance according to training prevalence, the relative performance of each model is still qualitatively the same across the range of prevalence values. 


![](Importance_by_Ratio.pdf)

**Figure S7:** Variable importance between the same models trained on either a 1:1 ratio of present to absent interactions (y-axis) or a 1:3 ratio (x-axis). Dotted black lines represent a 1:1 line; points that fall on the line indicate that relative importance of that variable was unaffected by training prevalence. We see that the marjority of features fall very close to the 1:1 line, including the most important variables (top right of each inset plot).This indicates are models are realtively insensitive to training prevalence. 

```{r, eval=FALSE, echo=FALSE}
split_output_1.1Ratio <- list()
for(i in 1:100){
    nas <- birds[gsub(" ", "_", birds$Frugivore_Species) %in%  Bird_trees[[round(i)]]$tip.label==FALSE,] %>% dplyr::select(., Frugivore_Species)  %>% unique() #Extract Bird taxa that don't occur in our tree
    genera <- sub("_[^ ]+$", "", Bird_trees[[round(i)]]$tip.label) %>% unique() #Genera list present in our bird tree
    nas$genus <- sub(" [^ ]+$", "", nas$Frugivore_Species) #Extract only genera of the nas
    nas <- nas[nas$genus %in% genera,] #Remove species without congeneric already in the tree
    nas <- nas[grepl(" ", nas$Frugivore_Species)==TRUE,] #Remove interactions only assigned to the genus level-this leaves just 1 warbler species
    ult_birdTree <- force.ultrametric(Bird_trees[[round(i)]]) #Our tree should already be ultrametric, but just in case
    polytree <- ult_birdTree #new tree object
    for(j in 1:nrow(nas)){ #add in our missing genera as polytomies
      polytree <- phytools::add.species.to.genus(tree=polytree, species=nas$Frugivore_Species[j], where="root") #Create polytomy at the genera root. 
    }
    #length(polytree$tip.label) - length(ult_birdTree$tip.label) #Number of net gained tips
  
  #Set up Phylogeny
  frug_litter <- PVR::PVRdecomp(phy=polytree, type="newick", scale=TRUE)
  frug_PhyEig <-data.frame(polytree$tip.label, frug_litter@Eigen$vectors[,1:3]) #take first three vectors and make them a dataframe
  colnames(frug_PhyEig) <- c("Frugivore_Species", "fc1", "fc2", "fc3")
  frug_PhyEig$Frugivore_Species <- gsub(pattern="_", replace=" ", x=frug_PhyEig$Frugivore_Species) 
  birds_temp <- left_join(birds, frug_PhyEig, by="Frugivore_Species") #Make a new object that includes our phylo information
  
  rebalancedRF_Phy <- woodedWalk(birds_temp, FrugTraits = c(f_phylo), PlantTraits = c(p_phylo), class_balancing = TRUE, balance_ratio = 1)
  rebalancedRF_Traits <- woodedWalk(birds_temp, FrugTraits = c(f_traits), PlantTraits = c(p_traits), class_balancing = TRUE, balance_ratio = 1 )
  rebalancedRF_Latent <- woodedWalk(birds_temp, FrugTraits = c(f_latent), PlantTraits = c(p_latent), class_balancing = TRUE, balance_ratio = 1)
  rebalancedRF_PhyTraits <- woodedWalk(birds_temp, FrugTraits = c(f_phylo, f_traits), PlantTraits = c(p_phylo, p_traits), class_balancing = TRUE, balance_ratio = 1)
  rebalancedRF_TraitsLatent <- woodedWalk(birds_temp, FrugTraits = c(f_latent, f_traits), PlantTraits = c(p_latent, p_traits), class_balancing = TRUE, balance_ratio = 1)
  rebalancedRF_PhyLatent <- woodedWalk(birds_temp, FrugTraits = c(f_latent, f_phylo), PlantTraits = c(p_latent, p_phylo), class_balancing = TRUE, balance_ratio = 1)
  rebalancedRF_Trio <- woodedWalk(birds_temp, FrugTraits = c(f_phylo, f_latent, f_traits), PlantTraits = c(p_phylo, p_latent, p_traits), class_balancing = TRUE, balance_ratio = 1)
  
  temp <- list(Phy=rebalancedRF_Phy, 
               Traits=rebalancedRF_Traits,
               Latent=rebalancedRF_Latent,
               PhyTraits=rebalancedRF_PhyTraits,
               TraitsLatent=rebalancedRF_TraitsLatent,
               PhyLatent=rebalancedRF_PhyLatent,
               Trio=rebalancedRF_Trio,
               run=i
               )
  split_output_1.1Ratio[[i]] <- temp
}


split_output_1.10Ratio <- list()
for(i in 1:100){
    nas <- birds[gsub(" ", "_", birds$Frugivore_Species) %in%  Bird_trees[[round(i)]]$tip.label==FALSE,] %>% dplyr::select(., Frugivore_Species)  %>% unique() #Extract Bird taxa that don't occur in our tree
    genera <- sub("_[^ ]+$", "", Bird_trees[[round(i)]]$tip.label) %>% unique() #Genera list present in our bird tree
    nas$genus <- sub(" [^ ]+$", "", nas$Frugivore_Species) #Extract only genera of the nas
    nas <- nas[nas$genus %in% genera,] #Remove species without congeneric already in the tree
    nas <- nas[grepl(" ", nas$Frugivore_Species)==TRUE,] #Remove interactions only assigned to the genus level-this leaves just 1 warbler species
    ult_birdTree <- force.ultrametric(Bird_trees[[round(i)]]) #Our tree should already be ultrametric, but just in case
    polytree <- ult_birdTree #new tree object
    for(j in 1:nrow(nas)){ #add in our missing genera as polytomies
      polytree <- phytools::add.species.to.genus(tree=polytree, species=nas$Frugivore_Species[j], where="root") #Create polytomy at the genera root. 
    }
    #length(polytree$tip.label) - length(ult_birdTree$tip.label) #Number of net gained tips
  
  #Set up Phylogeny
  frug_litter <- PVR::PVRdecomp(phy=polytree, type="newick", scale=TRUE)
  frug_PhyEig <-data.frame(polytree$tip.label, frug_litter@Eigen$vectors[,1:3]) #take first three vectors and make them a dataframe
  colnames(frug_PhyEig) <- c("Frugivore_Species", "fc1", "fc2", "fc3")
  frug_PhyEig$Frugivore_Species <- gsub(pattern="_", replace=" ", x=frug_PhyEig$Frugivore_Species) 
  birds_temp <- left_join(birds, frug_PhyEig, by="Frugivore_Species") #Make a new object that includes our phylo information
  
  rebalancedRF_Phy <- woodedWalk(birds_temp, FrugTraits = c(f_phylo), PlantTraits = c(p_phylo), class_balancing = TRUE, balance_ratio = 10)
  rebalancedRF_Traits <- woodedWalk(birds_temp, FrugTraits = c(f_traits), PlantTraits = c(p_traits), class_balancing = TRUE, balance_ratio = 10 )
  rebalancedRF_Latent <- woodedWalk(birds_temp, FrugTraits = c(f_latent), PlantTraits = c(p_latent), class_balancing = TRUE, balance_ratio = 10)
  rebalancedRF_PhyTraits <- woodedWalk(birds_temp, FrugTraits = c(f_phylo, f_traits), PlantTraits = c(p_phylo, p_traits), class_balancing = TRUE, balance_ratio = 10)
  rebalancedRF_TraitsLatent <- woodedWalk(birds_temp, FrugTraits = c(f_latent, f_traits), PlantTraits = c(p_latent, p_traits), class_balancing = TRUE, balance_ratio = 10)
  rebalancedRF_PhyLatent <- woodedWalk(birds_temp, FrugTraits = c(f_latent, f_phylo), PlantTraits = c(p_latent, p_phylo), class_balancing = TRUE, balance_ratio = 10)
  rebalancedRF_Trio <- woodedWalk(birds_temp, FrugTraits = c(f_phylo, f_latent, f_traits), PlantTraits = c(p_phylo, p_latent, p_traits), class_balancing = TRUE, balance_ratio = 10)
  
  temp <- list(Phy=rebalancedRF_Phy, 
               Traits=rebalancedRF_Traits,
               Latent=rebalancedRF_Latent,
               PhyTraits=rebalancedRF_PhyTraits,
               TraitsLatent=rebalancedRF_TraitsLatent,
               PhyLatent=rebalancedRF_PhyLatent,
               Trio=rebalancedRF_Trio,
               run=i
               )
  split_output_1.10Ratio[[i]] <- temp
}

save(split_output_1.10Ratio, split_output_1.1Ratio, file="../Data.nosync/Results/Variable_BalancRatios.Rda")
```


```{r, eval=FALSE, echo=FALSE}
#Extracting the performance metrics from our alternative balance ratio runs. 
load("../Data.nosync/Results/Variable_BalancRatios.Rda")
performance1.10 <- NULL
for(i in 1:100){
  performance1.10 <- NULL
  for(i in 1:100){
    for(j in 1:7){
      temp <- data.frame(model=names(split_output_1.10Ratio[[i]])[j],
                            run=i,
                            acc=split_output_1.10Ratio[[i]][[j]]$acc,
                            auc=split_output_1.10Ratio[[i]][[j]]$auc,
                            mrse=split_output_1.10Ratio[[i]][[j]]$mrse,
                            H=split_output_1.10Ratio[[i]][[j]]$H)
      performance1.10 <- rbind(performance1.10, temp)
    }
  }
}

performance1.1 <- NULL
for(i in 1:100){
  performance1.1 <- NULL
  for(i in 1:100){
    for(j in 1:7){
      temp <- data.frame(model=names(split_output_1.1Ratio[[i]])[j],
                            run=i,
                            acc=split_output_1.1Ratio[[i]][[j]]$acc,
                            auc=split_output_1.1Ratio[[i]][[j]]$auc,
                            mrse=split_output_1.1Ratio[[i]][[j]]$mrse,
                            H=split_output_1.1Ratio[[i]][[j]]$H)
      performance1.1 <- rbind(performance1.1, temp)
    }
  }
}

performance$ratio <- 3
performance1.1$ratio <- 1
performance1.10$ratio <- 10

ratioperf <- rbind(performance, performance1.1, performance1.10)
save(ratioperf, file="performance_metrics_prevalence.RDA")
```

```{r, eval=FALSE, echo=FALSE}
#pdf("AUC_Ratio.pdf")
ggplot(data=ratioperf, aes(y=auc, x=as.factor(model), fill=as.factor(ratio)))+
  geom_boxplot()+
  theme_classic()+
  ylab("AUC Predicting Test Set")+
  xlab("Model")+
  guides(fill=guide_legend("Ratio of \npositive:negative \ncases in \ntraining set"))+
  scale_fill_discrete(labels=c("1:1 (50%)", "1:3 (25%)", "1:10 (9%)"))
#dev.off()

#pdf(file="MRSE_Ratio.pdf", width=6, height=6)
ggplot(data=ratioperf, aes(y=mrse, x=as.factor(model), fill=as.factor(ratio)))+
  geom_boxplot(lwd=0.1, outlier.size=0.2)+
  theme_classic()+
  ylab("MRSE Predicting Test Set")+
  xlab("Model")+
  guides(fill=guide_legend("Ratio of \npositive:negative \ncases in \ntraining set"))+
  scale_fill_discrete(labels=c("1:1 (50%)", "1:3 (25%)", "1:10 (9%)"))
#dev.off()
```



```{r, eval=FALSE, echo=FALSE}
#Let's further compare the effects on variable importance below. 
split_output_1.1Ratio.rf <- list()
for(i in 1:100){
    nas <- birds[gsub(" ", "_", birds$Frugivore_Species) %in%  Bird_trees[[round(i)]]$tip.label==FALSE,] %>% dplyr::select(., Frugivore_Species)  %>% unique() #Extract Bird taxa that don't occur in our tree
    genera <- sub("_[^ ]+$", "", Bird_trees[[round(i)]]$tip.label) %>% unique() #Genera list present in our bird tree
    nas$genus <- sub(" [^ ]+$", "", nas$Frugivore_Species) #Extract only genera of the nas
    nas <- nas[nas$genus %in% genera,] #Remove species without congeneric already in the tree
    nas <- nas[grepl(" ", nas$Frugivore_Species)==TRUE,] #Remove interactions only assigned to the genus level-this leaves just 1 warbler species
    ult_birdTree <- force.ultrametric(Bird_trees[[round(i)]]) #Our tree should already be ultrametric, but just in case
    polytree <- ult_birdTree #new tree object
    for(j in 1:nrow(nas)){ #add in our missing genera as polytomies
      polytree <- phytools::add.species.to.genus(tree=polytree, species=nas$Frugivore_Species[j], where="root") #Create polytomy at the genera root. 
    }
    #length(polytree$tip.label) - length(ult_birdTree$tip.label) #Number of net gained tips
  #Set up Phylogeny
  frug_litter <- PVR::PVRdecomp(phy=polytree, type="newick", scale=TRUE)
  frug_PhyEig <-data.frame(polytree$tip.label, frug_litter@Eigen$vectors[,1:3]) #take first three vectors and make them a dataframe
  colnames(frug_PhyEig) <- c("Frugivore_Species", "fc1", "fc2", "fc3")
  frug_PhyEig$Frugivore_Species <- gsub(pattern="_", replace=" ", x=frug_PhyEig$Frugivore_Species) 
  birds_temp <- left_join(birds, frug_PhyEig, by="Frugivore_Species") #Make a new object that includes our phylo information
  
  rebalancedRF_Phy <- woodedWalk(birds_temp, FrugTraits = c(f_phylo), PlantTraits = c(p_phylo), class_balancing = TRUE, balance_ratio = 1, output_type = "rfobject")
  rebalancedRF_Traits <- woodedWalk(birds_temp, FrugTraits = c(f_traits), PlantTraits = c(p_traits), class_balancing = TRUE, balance_ratio = 1 , output_type = "rfobject")
  rebalancedRF_Latent <- woodedWalk(birds_temp, FrugTraits = c(f_latent), PlantTraits = c(p_latent), class_balancing = TRUE, balance_ratio = 1, output_type = "rfobject")
  rebalancedRF_PhyTraits <- woodedWalk(birds_temp, FrugTraits = c(f_phylo, f_traits), PlantTraits = c(p_phylo, p_traits), class_balancing = TRUE, balance_ratio = 1, output_type = "rfobject")
  rebalancedRF_TraitsLatent <- woodedWalk(birds_temp, FrugTraits = c(f_latent, f_traits), PlantTraits = c(p_latent, p_traits), class_balancing = TRUE, balance_ratio = 1, output_type = "rfobject")
  rebalancedRF_PhyLatent <- woodedWalk(birds_temp, FrugTraits = c(f_latent, f_phylo), PlantTraits = c(p_latent, p_phylo), class_balancing = TRUE, balance_ratio = 1, output_type = "rfobject")
  rebalancedRF_Trio <- woodedWalk(birds_temp, FrugTraits = c(f_phylo, f_latent, f_traits), PlantTraits = c(p_phylo, p_latent, p_traits), class_balancing = TRUE, balance_ratio = 1, output_type = "rfobject")
  
  temp <- list(Phy=rebalancedRF_Phy, 
               Traits=rebalancedRF_Traits,
               Latent=rebalancedRF_Latent,
               PhyTraits=rebalancedRF_PhyTraits,
               TraitsLatent=rebalancedRF_TraitsLatent,
               PhyLatent=rebalancedRF_PhyLatent,
               Trio=rebalancedRF_Trio,
               run=i
               )
  split_output_1.1Ratio.rf[[i]] <- temp
}

save(split_output_1.1Ratio.rf, file="../Data.nosync/Results/Variable_BalancRatios_Rfob.Rda")
```

```{r, eval=FALSE, echo=FALSE}
#Let's grab the variable importance summary for this update object
temp <- NULL
for(i in 1:100){
  # Phy
temp <- rbind(temp, data.frame(giniDec=split_output_1.1Ratio.rf[[i]]$Phy$importance, model="Phy", run=i, trait=c("FrugPhy1", "FrugPhy2", "FrugPhy3", "Plantphy1", "Plantphy2", "Plantphy3","Plantphy4")))


 # Traits
traitstemp <- group.importance(rf.obj=split_output_1.1Ratio.rf[[i]]$Traits, groups=list(
                growthform=c("tree","liana", "palm", "scrub"), 
               fruitcolor=c("yellow", "red", "black", "brown", "green"),
               LipidScore=c("Lipid_Score"),
               fruit_diameter=c("fruit_diameter"),
               fruit_length=c("fruit_length"),
              Frug_Body_Mass="Frug_Body_Mass",
              Frug_Mean_Gape_Size="Frug_Mean_Gape_Size",
              FrugScore="Frugivory_score")
               )
temp <- rbind(temp, data.frame(giniDec=traitstemp, model="Traits", run=i, trait=rownames(traitstemp)))
rm(traitstemp)
 #Latent
temp <- rbind(temp, data.frame(giniDec=split_output_1.1Ratio.rf[[i]]$Latent$importance, model="Latent", run=i, trait=c("p_latent1", "p_latent2","p_latent3","f_latent1","f_latent2","f_latent3")))

 #PhyTraits
phytraitstemp <- group.importance(rf.obj=split_output_1.1Ratio.rf[[i]]$PhyTraits, groups=list(
                growthform=c("tree","liana", "palm", "scrub"), 
               fruitcolor=c("yellow", "red", "black", "brown", "green"),
               LipidScore=c("Lipid_Score"),
               fruit_diameter=c("fruit_diameter"),
               fruit_length=c("fruit_length"),
              Frug_Body_Mass="Frug_Body_Mass",
              Frug_Mean_Gape_Size="Frug_Mean_Gape_Size",
              FrugScore="Frugivory_score",
              FrugPhy1="fc1",
              FrugPhy2="fc2",
              FrugPhy3="fc3",
              Plantphy1="c1PlPolyDecomp",
              Plantphy2="c2PlPolyDecomp",
              Plantphy3="c3PlPolyDecomp",
              Plantphy4="c4PlPolyDecomp"))
temp <- rbind(temp, data.frame(giniDec=phytraitstemp, model="PhyTraits", run=i, trait=rownames(phytraitstemp)))
rm(phytraitstemp)
 #TraitsLatent
traitslatenttemp <- group.importance(rf.obj=split_output_1.1Ratio.rf[[i]]$TraitsLatent, groups=list(
                growthform=c("tree","liana", "palm", "scrub"), 
               fruitcolor=c("yellow", "red", "black", "brown", "green"),
               LipidScore=c("Lipid_Score"),
               fruit_diameter=c("fruit_diameter"),
               fruit_length=c("fruit_length"),
              Frug_Body_Mass="Frug_Body_Mass",
              Frug_Mean_Gape_Size="Frug_Mean_Gape_Size",
              FrugScore="Frugivory_score",
              p_latent1="Psvd1",
              p_latent2="Psvd2",
              p_latent3="Psvd3",
              f_latent1="Fsvd1",
              f_latent2="Fsvd2",
              f_latent3="Fsvd3"))

temp <- rbind(temp, data.frame(giniDec=traitslatenttemp, model="TraitsLatent", run=i, trait=rownames(traitslatenttemp)))
rm(traitslatenttemp)
 #PhyLatent
phylatenttemp <- group.importance(rf.obj=split_output_1.1Ratio.rf[[i]]$PhyLatent, groups=list(
              p_latent1="Psvd1",
              p_latent2="Psvd2",
              p_latent3="Psvd3",
              f_latent1="Fsvd1",
              f_latent2="Fsvd2",
              f_latent3="Fsvd3",
              FrugPhy1="fc1",
              FrugPhy2="fc2",
              FrugPhy3="fc3",
              Plantphy1="c1PlPolyDecomp",
              Plantphy2="c2PlPolyDecomp",
              Plantphy3="c3PlPolyDecomp",
              Plantphy4="c4PlPolyDecomp"))
temp <- rbind(temp, data.frame(giniDec=phylatenttemp, model="PhyLatent", run=i, trait=rownames(phylatenttemp)))
rm(phylatenttemp)
 #Trio
triotemp <- group.importance(rf.obj=split_output_1.1Ratio.rf[[i]]$Trio, groups=list(
                growthform=c("tree","liana", "palm", "scrub"), 
               fruitcolor=c("yellow", "red", "black", "brown", "green"),
               LipidScore=c("Lipid_Score"),
               fruit_diameter=c("fruit_diameter"),
               fruit_length=c("fruit_length"),
              Frug_Body_Mass="Frug_Body_Mass",
              Frug_Mean_Gape_Size="Frug_Mean_Gape_Size",
              FrugScore="Frugivory_score",
              p_latent1="Psvd1",
              p_latent2="Psvd2",
              p_latent3="Psvd3",
              f_latent1="Fsvd1",
              f_latent2="Fsvd2",
              f_latent3="Fsvd3",
              FrugPhy1="fc1",
              FrugPhy2="fc2",
              FrugPhy3="fc3",
              Plantphy1="c1PlPolyDecomp",
              Plantphy2="c2PlPolyDecomp",
              Plantphy3="c3PlPolyDecomp",
              Plantphy4="c4PlPolyDecomp"))
temp <- rbind(temp, data.frame(giniDec=triotemp, model="Trio", run=i, trait=rownames(triotemp)))
rm(triotemp)
}

varimport_1.1Ratio <- temp

#varimporSummary <- varimport %>% dplyr::group_by(., model, trait) %>%VarImportance_Err dplyr::summarise(avg=(mean(MeanDecreaseGini)/max(MeanDecreaseGini)), sd=sd((MeanDecreaseGini)/MeanDecreaseGini))

varimport_1.1RatioSummary <- varimport_10.1Ratio %>% dplyr::group_by(., model, trait) %>% dplyr::summarise(avg=(mean(MeanDecreaseGini)), sd=sd((MeanDecreaseGini)))

varimport_1.1RatioSummary$trait %<>% as.factor()

varimporSummary$avg1.1 <- varimport_1.1RatioSummary$avg #Add 
varimporSummary$sd1.1 <- varimport_1.1RatioSummary$sd
```

```{r, eval=FALSE, echo=FALSE}
#Comparing the distribution of Relative Importance Values

varimporSummary2 <- varimporSummary
varimporSummary2 <- varimporSummary2 %>% group_by(model) %>% mutate(relav_base=avg/max(avg), relav_1.1=avg1.1/max(avg1.1))

varimporSummary2 <- varimporSummary2 %>% group_by(model) %>% mutate(relav_sd=sd/max(avg), relsd_1.1=sd1.1/max(avg1.1))

varimporSummary2$class <- NA
varimporSummary2$class[grepl("latent", varimporSummary2$trait)] <- "Latent"
varimporSummary2$class[grepl("hy", varimporSummary2$trait)] <- "Phylo"
varimporSummary2$class[is.na(varimporSummary2$class)==TRUE] <- "Trait"
save(varimporSummary2, file="Supplemental_Varimport_ratios.RDA")
```


```{r, eval=FALSE, echo=FALSE}
load("Supplemental_Varimport_ratios.RDA")

#pdf("Importance_by_Ratio.pdf", width=11, height=8.5)
varimporSummary2 %>% 
ggplot(data=., aes(x=relav_base, y=relav_1.1, color=as.factor(class)))+
  geom_segment(aes(x=0, y=0, xend=1, yend=1), col="black", lty=2)+
  xlab("Relative Variable Importance, 1:3 Ratio")+
  ylab("Relative Importance, 1:1 Ratio")+
  theme_classic()+
  geom_errorbar(aes(xmin = relav_base-1.96*relav_sd, xmax = relav_base+1.96*relav_sd), width = 0, col="darkgrey")+
  geom_errorbar(aes(ymin = relav_1.1-1.96*relsd_1.1, ymax = relav_1.1+1.96*relsd_1.1), width = 0, col="darkgrey")+
  geom_point(size=2, alpha=0.75)+facet_wrap(~model, nrow=2)+
  guides(color=guide_legend(title="Feature Type"))+
  theme(legend.position = c(0.85, 0.2), legend.text=element_text(size=16), legend.title=element_text(size=16))
#dev.off()

```


```{r, eval=FALSE, echo=FALSE}
#Comparing actual suitability difference
save(file="prereqs.rda", birds, Bird_trees, woodedWalk)
suitout <- NULL
for(ratioval in c(1, 3, 10)){
  for(i in 1:100){
      nas <- birds[gsub(" ", "_", birds$Frugivore_Species) %in%  Bird_trees[[round(i)]]$tip.label==FALSE,] %>% dplyr::select(., Frugivore_Species)  %>% unique() #Extract Bird taxa that don't occur in our tree
      genera <- sub("_[^ ]+$", "", Bird_trees[[round(i)]]$tip.label) %>% unique() #Genera list present in our bird tree
      nas$genus <- sub(" [^ ]+$", "", nas$Frugivore_Species) #Extract only genera of the nas
      nas <- nas[nas$genus %in% genera,] #Remove species without congeneric already in the tree
      nas <- nas[grepl(" ", nas$Frugivore_Species)==TRUE,] #Remove interactions only assigned to the genus level-this leaves just 1 warbler species
      ult_birdTree <- force.ultrametric(Bird_trees[[round(i)]]) #Our tree should already be ultrametric, but just in case
      polytree <- ult_birdTree #new tree object
      for(j in 1:nrow(nas)){ #add in our missing genera as polytomies
        polytree <- phytools::add.species.to.genus(tree=polytree, species=nas$Frugivore_Species[j], where="root") #Create polytomy at the genera root. 
      }
      #length(polytree$tip.label) - length(ult_birdTree$tip.label) #Number of net gained tips
    
    #Set up Phylogeny
    frug_litter <- PVR::PVRdecomp(phy=polytree, type="newick", scale=TRUE)
    frug_PhyEig <-data.frame(polytree$tip.label, frug_litter@Eigen$vectors[,1:3]) #take first three vectors and make them a dataframe
    colnames(frug_PhyEig) <- c("Frugivore_Species", "fc1", "fc2", "fc3")
    frug_PhyEig$Frugivore_Species <- gsub(pattern="_", replace=" ", x=frug_PhyEig$Frugivore_Species) 
    birds_temp <- left_join(birds, frug_PhyEig, by="Frugivore_Species") #Make a new object that includes our phylo information
    
    rebalancedRF_Phy <- woodedWalk(birds_temp, FrugTraits = c(f_phylo), PlantTraits = c(p_phylo), class_balancing = TRUE, returnTestTrain=TRUE, balance_ratio = ratioval, output_type = "rfobject")
    rebalancedRF_Phy_Suit <- rebalancedRF_Phy$test
    rebalancedRF_Phy_Suit$S <- predict(rebalancedRF_Phy$rfModel, rebalancedRF_Phy_Suit, type="prob")[,1]
    rebalancedRF_Phy_Suit$model <- "Phy"
    rebalancedRF_Phy_Suit %<>% dplyr::select(., Frugivore_Species, Plant_Species, model, real, S)
    
    rebalancedRF_Traits <- woodedWalk(birds_temp, FrugTraits = c(f_traits), PlantTraits = c(p_traits), class_balancing = TRUE,  returnTestTrain=TRUE, balance_ratio = ratioval, output_type = "rfobject")
    rebalancedRF_Traits_Suit <- rebalancedRF_Traits$test
    rebalancedRF_Traits_Suit$S <- predict(rebalancedRF_Traits$rfModel, rebalancedRF_Traits_Suit, type="prob")[,1]
    rebalancedRF_Traits_Suit$model <- "Traits"
      rebalancedRF_Traits_Suit %<>% dplyr::select(., Frugivore_Species, Plant_Species, model, real, S)
  
    rebalancedRF_Latent <- woodedWalk(birds_temp, FrugTraits = c(f_latent), PlantTraits = c(p_latent), class_balancing = TRUE,  returnTestTrain=TRUE, balance_ratio = ratioval, output_type = "rfobject")
    rebalancedRF_Latent_Suit <- rebalancedRF_Latent$test
    rebalancedRF_Latent_Suit$S <- predict(rebalancedRF_Latent$rfModel, rebalancedRF_Latent_Suit, type="prob")[,1]
    rebalancedRF_Latent_Suit$model <- "Latent"
    rebalancedRF_Latent_Suit %<>% dplyr::select(., Frugivore_Species, Plant_Species, model, real, S)
  
    rebalancedRF_PhyTraits <- woodedWalk(birds_temp, FrugTraits = c(f_phylo, f_traits), PlantTraits = c(p_phylo, p_traits), class_balancing = TRUE,  returnTestTrain=TRUE, balance_ratio = ratioval, output_type = "rfobject")
    rebalancedRF_PhyTraits_Suit <- rebalancedRF_PhyTraits$test
    rebalancedRF_PhyTraits_Suit$S <- predict(rebalancedRF_PhyTraits$rfModel, rebalancedRF_PhyTraits_Suit, type="prob")[,1]
    rebalancedRF_PhyTraits_Suit$model <- "PhyTraits"
    rebalancedRF_PhyTraits_Suit %<>% dplyr::select(., Frugivore_Species, Plant_Species, model, real, S)
    
    rebalancedRF_TraitsLatent <- woodedWalk(birds_temp, FrugTraits = c(f_latent, f_traits), PlantTraits = c(p_latent, p_traits), class_balancing = TRUE,  returnTestTrain=TRUE, balance_ratio = ratioval, output_type = "rfobject")
    rebalancedRF_TraitsLatent_Suit <- rebalancedRF_TraitsLatent$test
    rebalancedRF_TraitsLatent_Suit$S <- predict(rebalancedRF_TraitsLatent$rfModel, rebalancedRF_TraitsLatent_Suit, type="prob")[,1]
    rebalancedRF_TraitsLatent_Suit$model <- "TraitsLatent"
    rebalancedRF_TraitsLatent_Suit %<>% dplyr::select(., Frugivore_Species, Plant_Species, model, real, S)
    
    rebalancedRF_PhyLatent <- woodedWalk(birds_temp, FrugTraits = c(f_latent, f_phylo), PlantTraits = c(p_latent, p_phylo), class_balancing = TRUE,  returnTestTrain=TRUE, balance_ratio = ratioval, output_type = "rfobject")
    rebalancedRF_PhyLatent_Suit <- rebalancedRF_PhyLatent$test
    rebalancedRF_PhyLatent_Suit$S <- predict(rebalancedRF_PhyLatent$rfModel, rebalancedRF_PhyLatent_Suit, type="prob")
    rebalancedRF_PhyLatent_Suit$model <- "PhyLatent"
    rebalancedRF_PhyLatent_Suit %<>% dplyr::select(., Frugivore_Species, Plant_Species, model, real, S)
    
    rebalancedRF_Trio <- woodedWalk(birds_temp, FrugTraits = c(f_phylo, f_latent, f_traits), PlantTraits = c(p_phylo, p_latent, p_traits), class_balancing = TRUE,  returnTestTrain=TRUE, balance_ratio = ratioval, output_type = "rfobject")
    rebalancedRF_Trio_Suit <- rebalancedRF_Trio$test
    rebalancedRF_Trio_Suit$S <- predict(rebalancedRF_Trio$rfModel, rebalancedRF_Trio_Suit, type="prob")[,1]
    rebalancedRF_Trio_Suit$model <- "Trio"
    rebalancedRF_Trio_Suit %<>% dplyr::select(., Frugivore_Species, Plant_Species, model, real, S)
    
    temp <- rbind(rebalancedRF_Traits_Suit,
                  rebalancedRF_Phy_Suit,
                  rebalancedRF_Latent_Suit,
                  rebalancedRF_PhyTraits_Suit,
                  rebalancedRF_PhyLatent_Suit,
                  rebalancedRF_TraitsLatent_Suit,
                  rebalancedRF_Trio_Suit)
    temp$run <- i
    temp$balanceratio <- ratioval
    suitout <- rbind(temp, suitout)
    print(paste(i, "complete of 100", sep=" "))
  }
}
save(suitout, file="AlternativeRatio_Suitabilities.rda")
```


```{r, eval=FALSE, echo=FALSE}
suitsum <- group_by(suitout, Frugivore_Species, Plant_Species, model, balanceratio) %>%
  dplyr::summarise(., S_mean=mean(S, na.rm=T), sd=sd(S, na.rm=T))

widesuit <- pivot_wider(suitsum, names_from = balanceratio, values_from = c(sd, S_mean))
```


```{r, eval=FALSE, echo=FALSE}
#Here's a default without scaling. 
#pdf("suitability_comp_unscaled.pdf")
ggplot(data=widesuit, aes(x=1-S_mean_1, y=1-S_mean_3, color=model))+
  geom_point()+
  theme_classic()+
  xlab("Suitability under 1:1")+
  ylab("Suitability under 1:3")+
  geom_abline (slope=1, linetype = "dashed", color="Red")+
  facet_wrap(~model, nrow=2)+
  theme(legend.position = c(0.9,0.2))+
  guides(color=guide_legend(title="Model"))
#dev.off()

cor.test(x=widesuit$S_mean_1, y=widesuit$S_mean_3, method="spearman")
```



```{r, eval=FALSE, echo=FALSE}
Svals <- dplyr::group_by(suitout, Plant_Species, Frugivore_Species, model) %>% dplyr::summarise(., avgsuit=1-mean(S, na.rm=T), n=n()) #Change to the right scale (0 for unlikely link). 
```

## In Defense of Latent Traits

Latent traits are derived from the observed network, which is an incomplete sample of some underlying "true" network that we're trying to predict. We might expect the ability of latent features to effectively predict links to be different across networks with different sample completeness. Here, we, attempt to characterize that sensitiviy through a null model approach. 

The function below takes an arbitray number of plants, frugivores, and "true" links between them and simulates a network based on those characteristics. Each frugivore and plant species is assigned an abundance value randomly drawn from a lognormal distribution. Links are randomly assigned across all potential interactions according to the abundance of both potential partners. Links between abundant species are more likely than links between rare species. While a simplistic, neutral process, this graph generation feature recapitulates long-tailed degree distributions and asymmetric specialization patterns frequently observed in empirical networks. 

Given this "true" observed network, we perform single-value decomposition to create latent features, extracting the first three axes of variation for all nodes as in the main text. From these features we create a euclidean distance matrix that represents the pairwise distances of each intraguild node combination in the three-dimensional space defined by these three latent trait axes. The result is a `f\timesf` and a `p\timesp` distance matrix, where `f` and `p` are the number of frugivores and plants, respectively. 

We then degrade this network, removing 50 links from the full set, again sampling non-randomly so that less abundant combinations of species are more likely to go unsampled. This serves to approximate an incomplete sampling process in an empirical system, where links between abundant partners are likely to be observed, but links between rare partners are more likely to be missed. We then repeat the process of single value decomposition and creation of an intriguild pairwise distance matrix. We then use spearman's rank correlations to compare the "true" distance matrix with that produced from the degraded network. If latent features are able to separate the ranks of most nodes even despite degradation, spearman's rank correlation should be high. However, if degrading the network severly alters node clustering, spearman's correlatio should be low between the true and observed distance matrices. By repeating this process across a range of degradation values (each time comparing back to the "true" network), we can start to characterize the sensitivity of latent features to incomplete sampling. 



Below, we paramaterize the "true" model with 787 plant species, 242 frugivores, and 3643 "true" links, the same size as our empirically observed network. We repeat the process of degrading the network 50 times, and present average decreases in spearman's rank correlation. 

```{r, eval=FALSE}
#n_plants <- 787; n_frugivores=242; n_links = 3643; n_observed = 300; backgroundratio=3 #for debugging

distcordecay <- function(n_plants = 100, n_frugivores = 50,
                                        n_links = 500, aundweightsamp=T) {
  # Generate all combinations
  interactions <- expand.grid(FrugivoreID = 1:n_frugivores,
                              PlantID = 1:n_plants) %>%
    left_join(data.frame(FrugivoreID = 1:n_frugivores,
                         FrugAbund = rlnorm(n_frugivores)), by = "FrugivoreID") %>%
    left_join(data.frame(PlantID = 1:n_plants,
                         PlantAbund = rlnorm(n_plants)), by = "PlantID") %>%
    mutate(AbundProd = PlantAbund * FrugAbund) #Make a column of abundance products
  # Assign "real" interactions using abundance-weighted probabilities
  interactions$real <- 0
  interactions$real[sample(1:nrow(interactions), size = n_links, replace = FALSE, prob = interactions$AbundProd)] <- 1
  
  ############################################################
  
  # Rename species
  interactions$FrugivoreID <- paste0("F", interactions$FrugivoreID)
  interactions$PlantID <- paste0("P", interactions$PlantID)
  
  # Perform SVD latent feature reduction
  mat_assym <- xtabs(real ~ FrugivoreID + PlantID, data = interactions) #Make adj matrix
  decomp <- svd(mat_assym)
  u <- decomp$u
  v <- data.frame(decomp$v)
  
    # Trait tables
  plantsSVD <- data.frame(PlantID = colnames(mat_assym),
                          Psvd1 = v[, 1], Psvd2 = v[, 2], Psvd3 = v[, 3])
  frugSVD <- data.frame(FrugivoreID = rownames(mat_assym),
                        Fsvd1 = u[, 1], Fsvd2 = u[, 2], Fsvd3 = u[, 3])
  
  #Create our true distance matrices to compare to
  pdistrue <- dist(plantsSVD[,2:4], diag=T, upper=T, method="euclidean")
  fdistrue <- dist(frugSVD[,2:4], diag=T, upper=T, method="euclidean")
  
  #############################################################
  
    output <- NULL
    #Now start subsampling to degrade the network
    for(loss in seq(50,n_links, by=50)){
      temp <- interactions
      temp$obs <- 0
      temp$obs[sample(which(interactions$real == 1), size = n_links-loss, replace = FALSE, prob=interactions$AbundProd[which(interactions$real == 1)])] <- 1 
      
      mat_assym <- xtabs(obs ~ FrugivoreID + PlantID, data = temp) #Make adj matrix of observed subsample
      decomp <- svd(mat_assym) #perform decomposition
      u <- decomp$u
      v <- data.frame(decomp$v)
      
      plantsSVD <- data.frame(PlantID = colnames(mat_assym),
                          Psvd1 = v[, 1], Psvd2 = v[, 2], Psvd3 = v[, 3])
      frugSVD <- data.frame(FrugivoreID = rownames(mat_assym),
                        Fsvd1 = u[, 1], Fsvd2 = u[, 2], Fsvd3 = u[, 3])
      
      pdistemp <- dist(plantsSVD[,2:4], diag=T, upper=T, method="euclidean") #Create distance matrices
      fdistemp <- dist(frugSVD[,2:4], diag=T, upper=T, method="euclidean")
      pcor <- cor(pdistrue,pdistemp, method="spearman") #correlate our real distance matrices with our simulated subsets
      fcor <- cor(fdistrue,fdistemp, method="spearman")
      
      ret <- data.frame(loss=loss,plantcor=pcor, frugcor=fcor) #grab our correlations
      output <- rbind(ret, output)
      #print(paste(loss, "complete"))
    }
return(output)
}

```

```{r, eval=FALSE}
set.seed(1)
decayfull <- NULL
for(i in 1:50){
  temp <- distcordecay(n_plants = 787, n_frugivores = 242,
                                        n_links = 3643, aundweightsamp=T)
  temp$run <- i
  decayfull <- rbind(temp, decayfull)
  print(paste(i, "complete"))
}
#save(decayfull, file="decaytestFull.RDA")
```


```{r, echo=FALSE}
load(file="decaytestFull.RDA")
decaysum <- dplyr::group_by(decayfull, loss) %>% dplyr::summarise(., mnplantcor=mean(plantcor),
                                                                  sdplantcor=sd(plantcor),
                                                                  mnfrugcor=mean(frugcor),
                                                                  sfrugcor=sd(frugcor),
                                                                  nron=length(unique(run)))

min(decaysum$loss[decaysum$mnplantcor<0.75])/3643
min(decaysum$loss[decaysum$mnfrugcor<0.75])/3643

```

```{r, echo=FALSE}
# Make long format for easier plotting
decaysum_long <- tidyr::pivot_longer(
  decaysum,
  cols = c(mnplantcor, mnfrugcor),
  names_to = "type",
  values_to = "mean_cor"
)

# Match standard deviation columns
decaysum_long$sd <- ifelse(decaysum_long$type == "mnplantcor", 
                           decaysum$sdplantcor, 
                           decaysum$sfrugcor)

# Plot
pdf(file="decaysumplot.pdf", width=8, height=8)
ggplot(decaysum_long, aes(x = loss/max(loss), y = mean_cor, color = type)) +
  geom_point() +
  geom_line() +
  geom_errorbar(aes(ymin = mean_cor - sd, ymax = mean_cor + sd), width = 0.02, alpha=0.5) +
  scale_color_manual(values = c("mnplantcor" = "forestgreen", "mnfrugcor" = "steelblue"),
                     labels = c("Frugivore", "Plant"),
                     name = "Node Type") +
  labs(x = "Proportion of Links Removed", y = "Spearman's Correlation of Pairwise Distance values") +
  theme_light()
dev.off()
```

![]("decaysumplot.pdf")

**Figure S8:** Plot of intraguild latent pairwise distance matrices derived from compared to the true network (spearman's rank correlation); lines represent mean values across 50 iterations, while error bars represent standard deviation. Correlation decreases as links are removed for both frugivore (blue) and plant (green) nodes, but generally decreases slowly until a high proportion of links are removed. Distance matrices exhibit $\rho>0.75$ for plant and frugivore species even after removing 64.5% and 76.9% of links, respectively. 



We also are interested in the ability of latent features to cpature neutral processes given the aforementioned feature of incomplete sampling. Below, we simulate a number of "true" networks where attatchment is again only a function of species abundances drawn from a lognormal distribution. 


Below, we load in our analysis function from the main text. 
```{r, eval=FALSE}
#First load in our analysis function from the maintext
woodedWalk_NoSplit <- function(dat, FrugTraits, PlantTraits, class_balancing=FALSE, balance_ratio=3, output_type="rfobject"){
  if((output_type %in% c("rfobject", "predictions"))==FALSE){
    stop("Invalid output_type: choices are performance or rfobject")
  }
  #Set up our data into a fully expanded edgelist
  require(tidyr)
  dat$real <- 1 #make a new column denoting all of these edges are real; important when we expand out to all pairwise connections later
  dat <- dplyr::filter_at(dat, vars(c(FrugTraits, PlantTraits)), all_vars(!is.na(.))) #make sure we have data for all our predictors
  
  dat <- dplyr::select_at(dat, vars(c(Frugivore_Species, Plant_Species, real, FrugTraits, PlantTraits))) #Select our relevant predictors
  dat %<>% unique(.) #Make sure we only have unique entries
  full_L <- tidyr::expand(dat, Frugivore_Species, Plant_Species) #Expand to include all possible pairwise plant-frugivore interactions.
  full_real <- dplyr::select(dat, Frugivore_Species, Plant_Species, real) %>% left_join(full_L, ., by = c("Frugivore_Species", "Plant_Species")) #notating which of our edges in this expanded data are real 
  full_real$real[is.na(full_real$real)==TRUE] <- 0

  full_real_frugs <- dat[,c("Frugivore_Species", FrugTraits)] %>% unique() %>% left_join(full_real, ., by="Frugivore_Species") #Add in our frugivore traits

  full_real_both <- dat[,c("Plant_Species", PlantTraits)] %>% unique() %>% left_join(full_real_frugs, ., by="Plant_Species") #add in our plant traits
  
  full_real_both$real <- as.factor(full_real_both$real)
  
  rf<-randomForest::randomForest(real ~. -Frugivore_Species - Plant_Species, data=full_real_both, ntree=100)
  #ROC <- roc(full_real_both$real, rf$votes[,2])
  predictions <- stats::predict(rf, newdata=full_real_both, type="prob")
  
  if(output_type=="predictions"){
    output <- full_real_both %>% select(., "Frugivore_Species", "Plant_Species", real)
    output$S <- predictions[,2]
    return(output)
  }
  
  if(output_type=="rfobject"){
    output <- rf
  return(output)
  }
}


```

Next, we create a situation where empirical networks using the generation process outlined above. We also here define a sampling rate, specifying the number of links observed in addition to the number of true links. 

We use singular value decomposition on the osberved network, and use those features to inform a random forest model trained on the observed positive interactions and enough background points to create a 25% prevalence. We evaluate this model through AUC on the held-out positive links as well as enough new background points to again acheive a 25% prevalence on the test set. 



```{r, eval=FALSE}
#n_plants <- 100; n_frugivores=50; n_links = 500; n_observed = 300; backgroundratio=3 #for debugging
run_latent_trait_skewsamp_simulation <- function(n_plants = 100, n_frugivores = 50,
                                        n_links = 500, n_observed = 300, backgroundratio=3, rndm=FALSE, aundweightsamp=T) {
  # Generate all combinations
  interactions <- expand.grid(FrugivoreID = 1:n_frugivores,
                              PlantID = 1:n_plants) %>%
    left_join(data.frame(FrugivoreID = 1:n_frugivores,
                         FrugAbund = rlnorm(n_frugivores)), by = "FrugivoreID") %>%
    left_join(data.frame(PlantID = 1:n_plants,
                         PlantAbund = rlnorm(n_plants)), by = "PlantID") %>%
    mutate(AbundProd = PlantAbund * FrugAbund) #Make a column of abundance products
  # Assign "real" interactions using abundance-weighted probabilities
  interactions$real <- 0
  interactions$real[sample(1:nrow(interactions), size = n_links, replace = FALSE, prob = interactions$AbundProd)] <- 1
 
  interactions$obs <- NA
  
  Y <- xtabs(real ~ FrugivoreID + PlantID, data = interactions) #Make adj matrix
  Y
  
  if(aundweightsamp==T){ # Degrade the network by hiding some links AGAIN ABUNDANCE SAMPLING
  interactions$obs[sample(which(interactions$real == 1), size = n_observed, replace = FALSE, prob=interactions$AbundProd[which(interactions$real == 1)])] <- 1 #Correctly get n_observed BASED ON ABUND
  }
  if(aundweightsamp==F){ # Degrade the network by hiding some links RANDOM SAMPLING
  interactions$obs[sample(which(interactions$real == 1), size = n_observed, replace = FALSE)] <- 1 #Correctly get n_observed BASED ON ABUND
  }
  
  interactions$obs[is.na(interactions$obs)] <- 0
  # Rename species
  interactions$FrugivoreID <- paste0("F", interactions$FrugivoreID)
  interactions$PlantID <- paste0("P", interactions$PlantID)
  # Perform SVD latent feature reduction
  mat_assym <- xtabs(obs ~ FrugivoreID + PlantID, data = interactions) #Make adj matrix
  decomp <- svd(mat_assym)
  u <- decomp$u
  v <- data.frame(decomp$v)
  # Trait tables
  plantsSVD <- data.frame(PlantID = colnames(mat_assym),
                          Psvd1 = v[, 1], Psvd2 = v[, 2], Psvd3 = v[, 3])
  frugSVD <- data.frame(FrugivoreID = rownames(mat_assym),
                        Fsvd1 = u[, 1], Fsvd2 = u[, 2], Fsvd3 = u[, 3])
  # Merge traits
  interactions <- interactions %>%
    left_join(plantsSVD, by = "PlantID") %>%
    left_join(frugSVD, by = "FrugivoreID")
  # Create test/training split
  test <- filter(interactions, real == 1 & obs == 0) #Test is all unoberved real
  background <- filter(interactions, real == 0)
  test <- bind_rows(test, background[sample(nrow(background), backgroundratio * nrow(test)), ])
  
  
  #Add in some other missed 0's as a background ratio
  test$combo <- paste(test$FrugivoreID, test$PlantID, sep = "-") #create unifying column
  interactions$combo <- paste(interactions$FrugivoreID, interactions$PlantID, sep = "-")
  train <- filter(interactions, !combo %in% test$combo) #training is everything left (should this be re-evaluated?)
  # Rename for woodedWalk
  train <- rename(train, Frugivore_Species = FrugivoreID, Plant_Species = PlantID)
  test  <- rename(test, Frugivore_Species = FrugivoreID, Plant_Species = PlantID)
  
  if(rndm==T){
  test$real <- sample(test$real, length(test$real), replace=F)
  }
  # Fit model based on latent traits
  out <- woodedWalk_NoSplit(train,
                            FrugTraits = c("Fsvd1", "Fsvd2", "Fsvd3"),
                            PlantTraits = c("Psvd1", "Psvd2", "Psvd3"), class_balancing = TRUE)
  
  test$S <- stats::predict(out, newdata = test, type = "prob")[, 2] #Grab Svals
  
  # Evaluate performance
  rOC <- roc(data = test, response = real, predictor = S)
  AUC <- rOC$auc
  return(AUC)
}
```


Below, we simulate this process across a variety of a) graph sizes, b) connectance values of the "true" graph, c) sampling completeness values, in order to characterize the potential of latent traits for prediction across this parameter space. This neutral case represents the absolute simplest case in which latent features may be useful. The only factor impacting species' probabilities to interact are their abundances, while in real systems there may be many unmeasured factors impacting interaction structures which latent features may be able to detect. It is however a useful investigation into how latent features might change across this parameter space. 

```{r, echo=FALSE, eval=FALSE}
gsizes <- data.frame(f=c(25,50,100),p=c(50,100,200))

result <- NULL
for(x in seq(0.05,0.95, by=0.05)){ #simulate across sampling completeness values 
    for(y in c(0.01, 0.05, 0.1, 0.2, 0.33)){ # simulate across connectance values
      for(g in 1:nrow(gsizes)){
        for(i in 1:nrep){
          temp <- try(data.frame(sampling=x,
                                 ntotlinks=round(gsizes[g,1]*gsizes[g,2]*y),
                                 gsize=gsizes[g,1]*gsizes[g,2],
                                 connectance=y,
                                 rep=i,AUC=run_latent_trait_skewsamp_simulation(n_plants = gsizes[g,2], n_frugivores = gsizes[g,1], n_links=round(gsizes[g,1]*gsizes[g,2]*y), n_observed=round(gsizes[g,1]*gsizes[g,2]*y*x), rndm=T)[1]))
        
        if(class(temp)=="try-error"){
          temp <- data.frame(sampling=x, ntotlinks=y, 
                                 gsize=gsizes[g,1]*gsizes[g,2],
                                 connectance=y,rep=i, AUC=NA)
        }
        result <- rbind(result,temp)
      }
    }
    }
        print(paste("done with sampling completeness of", x))
}

#save(result, file="selectversion2.RDA")
```


```{r, echo=FALSE, eval=FALSE}
load(file="selectversion2.RDA")
resum <- result %>% dplyr::group_by(., gsize, connectance, sampling) %>% dplyr::summarize(., mnAUC=mean(AUC), sdAUC=sd(AUC))
resum$degrade <- 1-resum$sampling


facetnames <- c(
                    `0.01` = "True Connectance: 1%",
                    `0.05` = "True Connectance: 5%",
                    `0.1` = "True Connectance: 10%",
                    `0.2` = "True Connectance: 20%"
                    )

#pdf(file="nullsimulationResult.pdf", width=8, height=8)
resum %>% dplyr::filter(., connectance<0.33) %>%
ggplot(data = ., aes(x = degrade, y = mnAUC, colour = as.factor(gsize))) +
  geom_line() +
  geom_errorbar(aes(ymin = mnAUC - sdAUC/sqrt(50), ymax = mnAUC + sdAUC/sqrt(50)), width = 0.02) +
  facet_wrap(~connectance, labeller = as_labeller(facetnames))+
  theme_classic()+ guides(colour=guide_legend(title="Graph Size"))+
  scale_color_discrete(labels=c('Small (75 nodes)', 'Medium (150 nodes)', 'Large (300 nodes)'))+
  ylab("Mean AUC")+
  xlab("Proportion of links removed")+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
#dev.off()
```


![]("nullsimulationResult.pdf")

**Figure S9:** Plot of mean decrease in AUC performance as a function of the proportion of links removed from the observed set. Plot facets represent alternative connectance values of the true graph; color represent alternative graph sizes. Aside from the extreme sparse case (connectance = 1%), latent features tended to perform best on the smallest graphs. Performance overall was highest on moderately sparse graphs (5% connectance); across all connectance values and graph sizes, model performance decreases with greater sample degredation. 

## References

Gotelli N.J. (2000) Null model analysis of species co-occurrence patterns. Ecology, 81, 2606-2621

Vzquez, D. P., Blthgen, N., Cagnolo, L., & Chacoff, N. P. (2009). Uniting pattern and process in plantanimal mutualistic networks: a review. Annals of botany, 103(9), 1445-1457.