to = dat$Plant_Species
) %>% graph_from_data_frame(directed=FALSE) #Create a graph with all unique plant-frugivore edges
mat <-get.adjacency(web, type="both", sparse = FALSE) #Create adjacency matrix from our newly created web
#isSymmetric.matrix(mat) #we should get a full symmetric adjacency matrix since we added the type="both" argument above; this makes sure
V(web)$type <- bipartite.mapping(web)$type #Assign our bipartite mapping to type
V(web)$color <-  NA #Create empty node-propert for color
V(web)$color[V(web)$type==TRUE] <- "red"
V(web)$color[V(web)$type==FALSE] <- "blue"
load("BIEN_subtree.Rda")
Mammal_trees <- ape::read.nexus(file="Data.nosync/VertLife_FrugMam/output.nex")
Bird_trees <- ape::read.nexus(file="Data.nosync/VertLife_FrugBird/output.nex")
dat <- dplyr::filter_at(dat, vars(Plant_Form, Frugivory_score, Lipid_Score, Fruit_color, Plant_origin), all_vars(!is.na(.))) #make sure we have scores for all our binary variables
dat %<>% dplyr::filter(., Fruit_color !="") #This Remove blank fruit color entries
dat$Plant_origin[dat$Plant_origin !="native"] <- "nonnative" #condense all nonnative plants into one (can revisit later)
#dat$real <- 1 # note that these are real interactions; important when we expand later
dat_old <- dat
dat$Frugivory_score <- paste("FrugScore", dat$Frugivory_score, sep="") #Make value names unambiguous as column names
dat$Lipid_Score <- paste("LipScore", dat$Lipid_Score, sep="")
categories <- list(Forms=unique(dat$Plant_Form), #take the unique entries of our categorical data and save them in a list; (less typing to assign column names based on them below)
Frugivory_score=unique(dat$Frugivory_score),
Lipid_Score=unique(dat$Lipid_Score),
Fruit_color=unique(dat$Fruit_color),
Plant_origin=unique(dat$Plant_origin)
)
dat_old <- dat
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Plant_Form, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Frugivory_score, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Lipid_Score, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Fruit_color, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Plant_origin, values_from = bin)
dat[, 32:ncol(dat)][is.na(dat[,32:ncol(dat)])==TRUE] <- 0 #Replae all NA's in our newly created columns with 0
dat <- left_join(dat, dat_old) #add back in our factor columns just in case we want them later
plant_litter <- PVR::PVRdecomp(phy=BIEN_subtree, type="newick", scale=TRUE)
sum((round((plant_litter@Eigen$values)/sum((plant_litter@Eigen$values)),3)*100)[1:5]) #first three vectors only contain about 28% of variation :(
plant_PhyEig <-data.frame(BIEN_subtree$tip.label, plant_litter@Eigen$vectors[,1:5])
colnames(plant_PhyEig) <- c("Plant_Species", paste(colnames(plant_PhyEig)[2:ncol(plant_PhyEig)], "PlDecomp", sep=""))
plant_PhyEig$Plant_Species <- gsub(pattern="_", replace=" ", x=plant_PhyEig$Plant_Species)
dat <- left_join(dat, plant_PhyEig, by="Plant_Species")
frug_tree <- ape::compute.brlen(frug_tree, 1) #set branch lengths to 1
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(magrittr)
library(igraph)
library(pROC)
library(BIEN)
library(np)
library(PVR)
library(ape)
library(phytools)
dat <- read.csv("Data.nosync/ATLANTIC_frugivory.csv")
dat %<>% filter(., Frugivore_Species != "Carollia castanea") #This bat has an incorrect gape size
dat <- dplyr::select(dat, -ID, -Latitude, -Longitude, -Study_Location, -Precision, -Study_Method, -Study.reference, -Doi.Link, -Frug_Population_Trend, -Frug_Migration_status)
dat %<>% unique(.)
bats <- dplyr::filter(dat, Frug_Group=="Bats")
birds <- dplyr::filter(dat, Frug_Class=="Aves")
web <- data.frame(
from = dat$Frugivore_Species,
to = dat$Plant_Species
) %>% graph_from_data_frame(directed=FALSE) #Create a graph with all unique plant-frugivore edges
mat <-get.adjacency(web, type="both", sparse = FALSE) #Create adjacency matrix from our newly created web
#isSymmetric.matrix(mat) #we should get a full symmetric adjacency matrix since we added the type="both" argument above; this makes sure
V(web)$type <- bipartite.mapping(web)$type #Assign our bipartite mapping to type
V(web)$color <-  NA #Create empty node-propert for color
V(web)$color[V(web)$type==TRUE] <- "red"
V(web)$color[V(web)$type==FALSE] <- "blue"
load("BIEN_subtree.Rda")
Mammal_trees <- ape::read.nexus(file="Data.nosync/VertLife_FrugMam/output.nex")
Bird_trees <- ape::read.nexus(file="Data.nosync/VertLife_FrugBird/output.nex")
dat <- dplyr::filter_at(dat, vars(Plant_Form, Frugivory_score, Lipid_Score, Fruit_color, Plant_origin), all_vars(!is.na(.))) #make sure we have scores for all our binary variables
dat %<>% dplyr::filter(., Fruit_color !="") #This Remove blank fruit color entries
dat$Plant_origin[dat$Plant_origin !="native"] <- "nonnative" #condense all nonnative plants into one (can revisit later)
#dat$real <- 1 # note that these are real interactions; important when we expand later
dat_old <- dat
dat$Frugivory_score <- paste("FrugScore", dat$Frugivory_score, sep="") #Make value names unambiguous as column names
dat$Lipid_Score <- paste("LipScore", dat$Lipid_Score, sep="")
categories <- list(Forms=unique(dat$Plant_Form), #take the unique entries of our categorical data and save them in a list; (less typing to assign column names based on them below)
Frugivory_score=unique(dat$Frugivory_score),
Lipid_Score=unique(dat$Lipid_Score),
Fruit_color=unique(dat$Fruit_color),
Plant_origin=unique(dat$Plant_origin)
)
dat_old <- dat
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Plant_Form, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Frugivory_score, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Lipid_Score, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Fruit_color, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Plant_origin, values_from = bin)
dat[, 32:ncol(dat)][is.na(dat[,32:ncol(dat)])==TRUE] <- 0 #Replae all NA's in our newly created columns with 0
dat <- left_join(dat, dat_old) #add back in our factor columns just in case we want them later
plant_litter <- PVR::PVRdecomp(phy=BIEN_subtree, type="newick", scale=TRUE)
sum((round((plant_litter@Eigen$values)/sum((plant_litter@Eigen$values)),3)*100)[1:5]) #first three vectors only contain about 28% of variation :(
plant_PhyEig <-data.frame(BIEN_subtree$tip.label, plant_litter@Eigen$vectors[,1:5])
colnames(plant_PhyEig) <- c("Plant_Species", paste(colnames(plant_PhyEig)[2:ncol(plant_PhyEig)], "PlDecomp", sep=""))
plant_PhyEig$Plant_Species <- gsub(pattern="_", replace=" ", x=plant_PhyEig$Plant_Species)
dat <- left_join(dat, plant_PhyEig, by="Plant_Species")
#' Plug and Play algorithm.
#' Applies the plug and play algorithm to data on environmental covariates at presence and background using multivariate Gaussian distribution for f and f1
#'
#'  @param dat input dataframe of plant-frugivore interactions in the format of the atlantic forest csv
#'  @param FrugTraits Names of columns in dat containing Frugivore traits you'd like to classify with. These must be numeric, with factor entries being converted into a series of binary variables.
#'  @param PlantTraits  Names of columns in dat containing Plant traits you'd like to classify with; same conditions as above
#'
#' @returns A list containing:
#'  f1 : Estimated Kernal Density of positive training cases
#'  f0 : Estimated Kernal Density of background training cases
#'  test :  Edgelist of test set; not informed in train
#'  train : The edgelist we trained our model on (randomly sampled 80% of total possible edges)
pp.kde <- function(dat, FrugTraits, PlantTraits){
#Set up our data into a fully expanded edgelist
require(tidyr)
dat$real <- 1 #make a new column denoting all of these edges are real; important when we expand out to all pairwise connections later
dat <- dplyr::filter_at(dat, vars(c(FrugTraits, PlantTraits)), all_vars(!is.na(.))) #make sure we have data for all our predictors
full_L <- tidyr::expand(dat, Frugivore_Species, Plant_Species) #Expand to include all possible pairwise plant-frugivore interactions.
full_real <- dplyr::select(dat, Frugivore_Species, Plant_Species, real) %>% left_join(full_L, ., by = c("Frugivore_Species", "Plant_Species")) #notating which of our edges in this expanded data are real
full_real$real[is.na(full_real$real)==TRUE] <- 0
full_real_frugs <- dat[,c("Frugivore_Species", FrugTraits)] %>% unique() %>% left_join(full_real, ., by="Frugivore_Species") #Add in our frugivore traits
full_real_both <- dat[,c("Plant_Species", PlantTraits)] %>% unique() %>% left_join(full_real_frugs, ., by="Plant_Species") #add in our plant traits
# Subsample our edgelist
sample_IDs <- sample(round(nrow(full_real_both)*0.8), replace=F) #subsample out 80% of our edges.
test <- full_real_both[-sample_IDs,] #assign 80% train set
train <- full_real_both[sample_IDs,]
#set up our data to go into npudens
p <- train[(train[,'real'] == 1), 4:ncol(train)] #positives cases (p)
bgrd <- train[,4:ncol(train)] #background (positive and negative) cases
require(np)
f1 <- np::npudens(p, bwmethod='normal-reference')
f0 <- np::npudens(bgrd, bwmethod='normal-reference')
model=list(f1, f0, test, train)
names(model) <- c("f1", "f0", "test", "train")
#browser
return(model)
}
predict.pp.kde <- function(model, x){
require(np)
f1 <- fitted(npudens(bws = model$f1$bws, edat = x, bwmethod = 'normal-reference'))
f0 <- fitted(npudens(bws = model$f0$bws, edat = x, bwmethod = 'normal-reference'))
#browser()
return(S = f1/f0)
}
bats_kde <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size", "FrugScore1", "FrugScore2", "FrugScore3"), PlantTraits = c("fruit_diameter", "fruit_length", "tree", "palm", "scrub", "yellow", "red", "black", "brown", "green", "LipScore1", "LipScore2"))
View(dat)
colnames(dat)
pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size", "FrugScore1", "FrugScore2", "FrugScore3"), PlantTraits = c("fruit_diameter", "fruit_length", "tree", "palm", "scrub", "yellow", "red", "black", "brown", "green", "LipScore1", "LipScore2"))
bats <- dplyr::filter(dat, Frug_Group=="Bats")
birds <- dplyr::filter(dat, Frug_Class=="Aves")
bats_kde <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size", "FrugScore1", "FrugScore2", "FrugScore3"), PlantTraits = c("fruit_diameter", "fruit_length", "tree", "palm", "scrub", "yellow", "red", "black", "brown", "green", "LipScore1", "LipScore2"))
bats_kde <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size", "FrugScore1", "FrugScore2", "FrugScore3"), PlantTraits = c("fruit_diameter", "fruit_length", "tree", "palm", "scrub", "yellow", "red", "black", "brown", "green", "LipScore1", "LipScore2"))
frug_litter <- PVR::PVRdecomp(phy=Mammal_trees[[1]], type="newick", scale=TRUE)
#sum((round((frug_litter@Eigen$values)/sum((frug_litter@Eigen$values)),3)*100)[1:3]) #first three vectors contain 66.4% of variation!!!
frug_PhyEig <-data.frame(Mammal_trees[[1]]$tip.label, frug_litter@Eigen$vectors[,1:4]) #take first three vectors and make them a dataframe
colnames(frug_PhyEig) <- c("Frugivore_Species", "fc1", "fc2", "fc3", "fc4")
frug_PhyEig$Frugivore_Species <- gsub(pattern="_", replace=" ", x=frug_PhyEig$Frugivore_Species)
bats_temp <- left_join(bats, frug_PhyEig, by="Frugivore_Species") #Make a new object that includes our phylo information
batsPhylo_kde <- pp.kde(bats_temp, FrugTraits = c("fc1", "fc2", "fc3", "fc4"), PlantTraits = c("c1PlDecomp", "c2PlDecomp", "c3PlDecomp", "c4PlDecomp"))
#Predictors include continuous variables plus plant form and lipid score
batsPhylo_kde$test$S <- predict.pp.kde(model=batsPhylo_kde, x=batsPhylo_kde$test[,4:ncol(batsPhylo_kde$test)]) #Predict on test set and assign suitability scores
AUC_BatsPhylo <- roc(data=batsPhylo_kde$test, response=real, predictor=S)
plot(AUC_BatsPhylo)
AUC_BatsPhylo
bats_kde <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size", "FrugScore1", "FrugScore2", "FrugScore3"), PlantTraits = c("fruit_diameter", "fruit_length", "tree", "palm", "scrub", "yellow", "red", "black", "brown", "green", "LipScore1", "LipScore2"))
bats_kde <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size"), PlantTraits = c("fruit_diameter", "fruit_length", "tree", "palm", "scrub", "yellow", "red", "black", "brown", "green", "LipScore1", "LipScore2"))
bats_kde <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size"), PlantTraits = c("fruit_diameter", "fruit_length"))
bats_kde$test$S <- predict.pp.kde(model=bats_kde, x=bats_kde$test[,4:ncol(bats_kde$test)]) #Predict on test set and assign suitability scores
AUC_BatsTraits <- roc(data=bats_kde$test, response=real, predictor=S)
plot(AUC_BatsTraits)
AUC_BatsTraits
#Predictors include continuous variables plus plant form and lipid score
table(bats$LipScore1)
table(bats$LipScore2)
bats_kde <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size"), PlantTraits = c("fruit_diameter", "fruit_length", "tree", "palm", "scrub", "yellow", "red", "black", "brown", "green"))
#Predictors include continuous variables plus plant form and lipid score
table(bats$palm)
View(bats)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(magrittr)
library(igraph)
library(pROC)
library(BIEN)
library(np)
library(PVR)
library(ape)
library(phytools)
dat <- read.csv("Data.nosync/ATLANTIC_frugivory.csv")
dat %<>% filter(., Frugivore_Species != "Carollia castanea") #This bat has an incorrect gape size
dat <- dplyr::select(dat, -ID, -Latitude, -Longitude, -Study_Location, -Precision, -Study_Method, -Study.reference, -Doi.Link, -Frug_Population_Trend, -Frug_Migration_status)
dat %<>% unique(.)
web <- data.frame(
from = dat$Frugivore_Species,
to = dat$Plant_Species
) %>% graph_from_data_frame(directed=FALSE) #Create a graph with all unique plant-frugivore edges
mat <-get.adjacency(web, type="both", sparse = FALSE) #Create adjacency matrix from our newly created web
#isSymmetric.matrix(mat) #we should get a full symmetric adjacency matrix since we added the type="both" argument above; this makes sure
V(web)$type <- bipartite.mapping(web)$type #Assign our bipartite mapping to type
V(web)$color <-  NA #Create empty node-propert for color
V(web)$color[V(web)$type==TRUE] <- "red"
V(web)$color[V(web)$type==FALSE] <- "blue"
load("BIEN_subtree.Rda")
Mammal_trees <- ape::read.nexus(file="Data.nosync/VertLife_FrugMam/output.nex")
Bird_trees <- ape::read.nexus(file="Data.nosync/VertLife_FrugBird/output.nex")
dat <- dplyr::filter_at(dat, vars(Plant_Form, Frugivory_score, Lipid_Score, Fruit_color, Plant_origin), all_vars(!is.na(.))) #make sure we have scores for all our binary variables
dat %<>% dplyr::filter(., Fruit_color !="") #This Remove blank fruit color entries
dat$Plant_origin[dat$Plant_origin !="native"] <- "nonnative" #condense all nonnative plants into one (can revisit later)
#dat$real <- 1 # note that these are real interactions; important when we expand later
dat_old <- dat
dat$Frugivory_score <- paste("FrugScore", dat$Frugivory_score, sep="") #Make value names unambiguous as column names
dat$Lipid_Score <- paste("LipScore", dat$Lipid_Score, sep="")
categories <- list(Forms=unique(dat$Plant_Form), #take the unique entries of our categorical data and save them in a list; (less typing to assign column names based on them below)
Frugivory_score=unique(dat$Frugivory_score),
Lipid_Score=unique(dat$Lipid_Score),
Fruit_color=unique(dat$Fruit_color),
Plant_origin=unique(dat$Plant_origin)
)
dat_old <- dat
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Plant_Form, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Frugivory_score, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Lipid_Score, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Fruit_color, values_from = bin)
dat <- dat %>% mutate(bin=1) %>% pivot_wider(., names_from = Plant_origin, values_from = bin)
View(dat)
colnames(dat)[32]
colnames(dat)[colnames(dat)="liana"]
colnames(dat)[colnames(dat)=="liana"]
which(colnames(dat)=="liana")
[colnames(dat)=="liana"]
which(colnames(dat)=="liana")
dat[, which(colnames(dat)=="liana"):ncol(dat)][is.na(dat[,which(colnames(dat)=="liana"):ncol(dat)])==TRUE] <- 0 #Replae all NA's in our newly created columns with 0
bats_kde <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size"), PlantTraits = c("fruit_diameter", "fruit_length", "tree", "palm", "scrub", "yellow", "red", "black", "brown", "green"))
plant_litter <- PVR::PVRdecomp(phy=BIEN_subtree, type="newick", scale=TRUE)
sum((round((plant_litter@Eigen$values)/sum((plant_litter@Eigen$values)),3)*100)[1:5]) #first three vectors only contain about 28% of variation :(
plant_PhyEig <-data.frame(BIEN_subtree$tip.label, plant_litter@Eigen$vectors[,1:5])
colnames(plant_PhyEig) <- c("Plant_Species", paste(colnames(plant_PhyEig)[2:ncol(plant_PhyEig)], "PlDecomp", sep=""))
plant_PhyEig$Plant_Species <- gsub(pattern="_", replace=" ", x=plant_PhyEig$Plant_Species)
dat <- left_join(dat, plant_PhyEig, by="Plant_Species")
#' Plug and Play algorithm.
#' Applies the plug and play algorithm to data on environmental covariates at presence and background using multivariate Gaussian distribution for f and f1
#'
#'  @param dat input dataframe of plant-frugivore interactions in the format of the atlantic forest csv
#'  @param FrugTraits Names of columns in dat containing Frugivore traits you'd like to classify with. These must be numeric, with factor entries being converted into a series of binary variables.
#'  @param PlantTraits  Names of columns in dat containing Plant traits you'd like to classify with; same conditions as above
#'
#' @returns A list containing:
#'  f1 : Estimated Kernal Density of positive training cases
#'  f0 : Estimated Kernal Density of background training cases
#'  test :  Edgelist of test set; not informed in train
#'  train : The edgelist we trained our model on (randomly sampled 80% of total possible edges)
pp.kde <- function(dat, FrugTraits, PlantTraits){
#Set up our data into a fully expanded edgelist
require(tidyr)
dat$real <- 1 #make a new column denoting all of these edges are real; important when we expand out to all pairwise connections later
dat <- dplyr::filter_at(dat, vars(c(FrugTraits, PlantTraits)), all_vars(!is.na(.))) #make sure we have data for all our predictors
full_L <- tidyr::expand(dat, Frugivore_Species, Plant_Species) #Expand to include all possible pairwise plant-frugivore interactions.
full_real <- dplyr::select(dat, Frugivore_Species, Plant_Species, real) %>% left_join(full_L, ., by = c("Frugivore_Species", "Plant_Species")) #notating which of our edges in this expanded data are real
full_real$real[is.na(full_real$real)==TRUE] <- 0
full_real_frugs <- dat[,c("Frugivore_Species", FrugTraits)] %>% unique() %>% left_join(full_real, ., by="Frugivore_Species") #Add in our frugivore traits
full_real_both <- dat[,c("Plant_Species", PlantTraits)] %>% unique() %>% left_join(full_real_frugs, ., by="Plant_Species") #add in our plant traits
# Subsample our edgelist
sample_IDs <- sample(round(nrow(full_real_both)*0.8), replace=F) #subsample out 80% of our edges.
test <- full_real_both[-sample_IDs,] #assign 80% train set
train <- full_real_both[sample_IDs,]
#set up our data to go into npudens
p <- train[(train[,'real'] == 1), 4:ncol(train)] #positives cases (p)
bgrd <- train[,4:ncol(train)] #background (positive and negative) cases
require(np)
f1 <- np::npudens(p, bwmethod='normal-reference')
f0 <- np::npudens(bgrd, bwmethod='normal-reference')
model=list(f1, f0, test, train)
names(model) <- c("f1", "f0", "test", "train")
#browser
return(model)
}
predict.pp.kde <- function(model, x){
require(np)
f1 <- fitted(npudens(bws = model$f1$bws, edat = x, bwmethod = 'normal-reference'))
f0 <- fitted(npudens(bws = model$f0$bws, edat = x, bwmethod = 'normal-reference'))
#browser()
return(S = f1/f0)
}
bats <- dplyr::filter(dat, Frug_Group=="Bats")
birds <- dplyr::filter(dat, Frug_Class=="Aves")
bats_kde <- pp.kde(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size"), PlantTraits = c("fruit_diameter", "fruit_length", "tree", "palm", "scrub", "yellow", "red", "black", "brown", "green"))
#Predictors include continuous variables plus plant form and lipid score
table(bats$palm)
bats_kde$test$S <- predict.pp.kde(model=bats_kde, x=bats_kde$test[,4:ncol(bats_kde$test)]) #Predict on test set and assign suitability scores
AUC_BatsTraits <- roc(data=bats_kde$test, response=real, predictor=S)
plot(AUC_BatsTraits)
AUC_BatsTraits
frug_litter <- PVR::PVRdecomp(phy=Mammal_trees[[1]], type="newick", scale=TRUE)
#sum((round((frug_litter@Eigen$values)/sum((frug_litter@Eigen$values)),3)*100)[1:3]) #first three vectors contain 66.4% of variation!!!
frug_PhyEig <-data.frame(Mammal_trees[[1]]$tip.label, frug_litter@Eigen$vectors[,1:4]) #take first three vectors and make them a dataframe
colnames(frug_PhyEig) <- c("Frugivore_Species", "fc1", "fc2", "fc3", "fc4")
frug_PhyEig$Frugivore_Species <- gsub(pattern="_", replace=" ", x=frug_PhyEig$Frugivore_Species)
bats_temp <- left_join(bats, frug_PhyEig, by="Frugivore_Species") #Make a new object that includes our phylo information
batsPhylo_kde <- pp.kde(bats_temp, FrugTraits = c("fc1", "fc2", "fc3", "fc4"), PlantTraits = c("c1PlDecomp", "c2PlDecomp", "c3PlDecomp", "c4PlDecomp"))
#Predictors include continuous variables plus plant form and lipid score
batsPhylo_kde$test$S <- predict.pp.kde(model=batsPhylo_kde, x=batsPhylo_kde$test[,4:ncol(batsPhylo_kde$test)]) #Predict on test set and assign suitability scores
AUC_BatsPhylo <- roc(data=batsPhylo_kde$test, response=real, predictor=S)
plot(AUC_BatsPhylo)
AUC_BatsPhylo
birds_kde <- pp.kde(birds, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size", "FrugScore1", "FrugScore2", "FrugScore3"), PlantTraits = c("fruit_diameter", "fruit_length", "tree","liana", "palm", "scrub", "yellow", "red", "black", "brown", "green", "LipScore1", "LipScore2", "LipScore3"))#Predictors include continuous variables plus plant form and lipid score
birds_kde$test$S <- predict.pp.kde(model=birds_kde, x=birds_kde$test[,4:ncol(birds_kde$test)]) #Predict on test set and assign suitability scores
AUC_birdsTraits <- roc(data=birds_kde$test, response=real, predictor=S)
plot(AUC_birdsTraits)
AUC_birdsTraits
frug_litter <- PVR::PVRdecomp(phy=Bird_trees[[5]], type="newick", scale=TRUE)
sum((round((frug_litter@Eigen$values)/sum((frug_litter@Eigen$values)),3)*100)[1:3]) #first three vectors contain 47% of variation
frug_PhyEig <-data.frame(Bird_trees[[5]]$tip.label, frug_litter@Eigen$vectors[,1:3]) #take first three vectors and make them a dataframe
colnames(frug_PhyEig) <- c("Frugivore_Species", "fc1", "fc2", "fc3")
frug_PhyEig$Frugivore_Species <- gsub(pattern="_", replace=" ", x=frug_PhyEig$Frugivore_Species)
birds_temp <- left_join(birds, frug_PhyEig, by="Frugivore_Species") #Make a new object that includes our phylo information
birdsPhylo_kde <- pp.kde(birds_temp, FrugTraits = c("fc1", "fc2", "fc3"), PlantTraits = c("c1PlDecomp", "c2PlDecomp", "c3PlDecomp", "c4PlDecomp"))
#Predictors include continuous variables plus plant form and lipid score
birdsPhylo_kde$test$S <- predict.pp.kde(model=birdsPhylo_kde, x=birdsPhylo_kde$test[,4:ncol(birdsPhylo_kde$test)]) #Predict on test set and assign suitability scores
AUC_BirdsPhylo <- roc(data=birdsPhylo_kde$test, response=real, predictor=S)
plot(AUC_BirdsPhylo)
AUC_BirdsPhylo
#pdf(file="PlugPlayTestAUC.pdf", height = 8.5, width=11)
par(mfrow=c(2,2))
plot(AUC_BatsTraits, main="Plug & Play Trait AUC; Bats")
mtext(paste("AUC", round(AUC_BatsTraits$auc, 3), sep="="), side=1)
plot(AUC_BatsPhylo, main="Plug & Play PhyloDecomposition AUC; Bats")
mtext(paste("AUC", round(AUC_BatsPhylo$auc, 3), sep="="), side=1)
plot(AUC_birdsTraits, main="Plug & Play Trait AUC; Birds")
mtext(paste("AUC", round(AUC_birdsTraits$auc, 3), sep="="), side=1)
plot(AUC_BirdsPhylo, main="Plug & Play PhyloDecomposition AUC; Birds")
mtext(paste("AUC", round(AUC_BirdsPhylo$auc, 3), sep="="), side=1)
vegstuff <- function(dat){
mat_assym <- as.data.frame.matrix(table(dat$Frugivore_Species, dat$Plant_Species)) #Rows = Frugivores, Columns = Plants
frugSim <- rowMeans(as.matrix(vegan::vegdist(mat_assym)))	 #What's my average distance from all other frugivores (higher means I'm more unique, lower means I'm more similiar)
plantSim <- rowMeans(as.matrix(vegan::vegdist(t(mat_assym)))) #Same thing for plants
simMat <- frugSim %*% t(plantSim)	#uniqueness of the plant * uniqueness of the frugivore
rownames(simMat) <- rownames(mat_assym)
data.frame(frugSim) %>% rownames_to_column("Frugivore_Species")
dat <- data.frame(frugSim) %>% rownames_to_column("Frugivore_Species") %>% left_join(dat, by="Frugivore_Species")
dat_new <- data.frame(plantSim) %>% rownames_to_column("Plant_Species") %>% left_join(dat, by="Plant_Species")
return(dat_new)
}
dat <- vegstuff(dat)
bats <- dplyr::filter(dat, Frug_Group=="Bats") %>% dplyr::select(., -frugSim, -plantSim)
bats <- vegstuff(bats)
bats_vegdist_kde <- pp.kde(bats, FrugTraits = c("frugSim"), PlantTraits = c("plantSim"))
#Predictors include continuous variables plus plant form and lipid score
bats_vegdist_kde$test$S <- predict.pp.kde(model=bats_vegdist_kde, x=bats_vegdist_kde$test[,4:ncol(bats_vegdist_kde$test)]) #Predict on test set and assign suitability scores
AUC_BatsVegdist <- roc(data=bats_vegdist_kde$test, response=real, predictor=S)
plot(AUC_BatsVegdist)
AUC_BatsVegdist
birds <- dplyr::filter(dat, Frug_Class=="Aves") %>% dplyr::select(., -frugSim, -plantSim)
birds <- vegstuff(birds)
birds_vegdist_kde <- pp.kde(birds, FrugTraits = c("frugSim"), PlantTraits = c("plantSim"))
#Predictors include continuous variables plus plant form and lipid score
birds_vegdist_kde$test$S <- predict.pp.kde(model=birds_vegdist_kde, x=birds_vegdist_kde$test[,4:ncol(birds_vegdist_kde$test)]) #Predict on test set and assign suitability scores
AUC_birdsVegdist <- roc(data=birds_vegdist_kde$test, response=real, predictor=S)
plot(AUC_birdsVegdist)
AUC_birdsVegdist
full_vegdist_kde <- pp.kde(dat, FrugTraits = c("frugSim"), PlantTraits = c("plantSim"))
#Predictors include continuous variables plus plant form and lipid score
full_vegdist_kde$test$S <- predict.pp.kde(model=full_vegdist_kde, x=full_vegdist_kde$test[,4:ncol(full_vegdist_kde$test)]) #Predict on test set and assign suitability scores
AUC_fullVegdist <- roc(data=full_vegdist_kde$test, response=real, predictor=S)
plot(AUC_fullVegdist)
AUC_fullVegdist
#pdf(file="PlugPlayVegDistAUC.pdf", height = 11, width=8.5)
par(mfrow=c(3,1))
plot(AUC_birdsVegdist, main="Plug & Play Vegdist AUC; Full")
mtext(paste("AUC", round(AUC_birdsVegdist$auc, 3), sep="="), side=1)
plot(AUC_fullVegdist, main="Plug & Play Vegdist AUC; Birds")
mtext(paste("AUC", round(AUC_fullVegdist$auc, 3), sep="="), side=1)
plot(AUC_BatsVegdist, main="Plug & Play Vegdist AUC; Bats")
mtext(paste("AUC", round(AUC_BatsVegdist$auc, 3), sep="="), side=1)
woodedWalk <- function(dat, FrugTraits, PlantTraits){
#Set up our data into a fully expanded edgelist
require(tidyr)
dat$real <- 1 #make a new column denoting all of these edges are real; important when we expand out to all pairwise connections later
dat <- dplyr::filter_at(dat, vars(c(FrugTraits, PlantTraits)), all_vars(!is.na(.))) #make sure we have data for all our predictors
full_L <- tidyr::expand(dat, Frugivore_Species, Plant_Species) #Expand to include all possible pairwise plant-frugivore interactions.
full_real <- dplyr::select(dat, Frugivore_Species, Plant_Species, real) %>% left_join(full_L, ., by = c("Frugivore_Species", "Plant_Species")) #notating which of our edges in this expanded data are real
full_real$real[is.na(full_real$real)==TRUE] <- 0
full_real_frugs <- dat[,c("Frugivore_Species", FrugTraits)] %>% unique() %>% left_join(full_real, ., by="Frugivore_Species") #Add in our frugivore traits
full_real_both <- dat[,c("Plant_Species", PlantTraits)] %>% unique() %>% left_join(full_real_frugs, ., by="Plant_Species") #add in our plant traits
full_real_both$real <- as.factor(full_real_both$real)
# Subsample our edgelist
sample_IDs <- sample(round(nrow(full_real_both)*0.8), replace=F) #subsample out 80% of our edges.
test <- full_real_both[-sample_IDs,] #assign 80% train set
train <- full_real_both[sample_IDs,]
rf<-randomForest::randomForest(real ~. -Frugivore_Species - Plant_Species, data=train, ntree=100)
trainROC <- roc(train$real,rf$votes[,2])
predictions <- stats::predict(rf, newdata=test, type="prob")
test$S <- predictions[,2]
model=list(rfModel=rf,test=test, train=train)
return(model)
}
bats_rf_traits <- woodedWalk(bats, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size", "FrugScore1", "FrugScore2", "FrugScore3"), PlantTraits = c("fruit_diameter", "fruit_length", "tree", "palm", "scrub", "yellow", "red", "black", "brown", "green", "LipScore1", "LipScore2"))
#Predictors include continuous variables plus plant form and lipid score
AUC_RF_BatsTraits <- roc(data=bats_rf$test, response=real, predictor=S)
AUC_RF_BatsTraits <- roc(data=bats_rf_traits$test, response=real, predictor=S)
plot(AUC_RF_BatsTraits)
AUC_RF_BatsTraits
bats_rf_plylo <- woodedWalk(bats_temp, FrugTraits = c("fc1", "fc2", "fc3", "fc4"), PlantTraits = c("c1PlDecomp", "c2PlDecomp", "c3PlDecomp", "c4PlDecomp"))
AUC_RF_BatsPhylo <- roc(data=bats_rf_plylo$test, response=real, predictor=S)
plot(AUC_RF_BatsPhylo)
AUC_RF_BatsPhylo
birds_rf_traits <- woodedWalk(birds, FrugTraits = c("Frug_Body_Mass","Frug_Mean_Gape_Size", "FrugScore1", "FrugScore2", "FrugScore3"), PlantTraits = c("fruit_diameter", "fruit_length", "tree","liana", "palm", "scrub", "yellow", "red", "black", "brown", "green", "LipScore1", "LipScore2", "LipScore3"))#Predictors include continuous variables plus plant form and lipid score
AUC_RF_BirdsTraits <- roc(data=birds_rf_traits$test, response=real, predictor=S)
plot(AUC_RF_BirdsTraits)
AUC_RF_BirdsTraits
birds_rf_plylo <- woodedWalk(birds_temp, FrugTraits = c("fc1", "fc2", "fc3"), PlantTraits = c("c1PlDecomp", "c2PlDecomp", "c3PlDecomp", "c4PlDecomp"))
#Predictors include continuous variables plus plant form and lipid score
AUC_RF_BirdsPhylo <- roc(data=birds_rf_plylo$test, response=real, predictor=S)
plot(AUC_RF_BirdsPhylo)
AUC_RF_BirdsPhylo
hist(degree_distribution(batweb))
plot(AUC_birdsVegdist, main="Plug & Play Vegdist AUC; Full")
mtext(paste("AUC", round(AUC_birdsVegdist$auc, 3), sep="="), side=1)
plot(AUC_birdsTraits, main="Plug & Play Traits AUC; Full")
mtext(paste("AUC", round(AUC_birdsTraits$auc, 3), sep="="), side=1)
plot(AUC_birdsTraits, main="Plug & Play Traits ROC; Birds")
mtext(paste("AUC", round(AUC_birdsTraits$auc, 3), sep="="), side=1)
plot(AUC_RF_BirdsTraits, main="Random Forest Traits ROC; Birds")
mtext(paste("AUC", round(AUC_RF_BirdsTraits$auc, 3), sep="="), side=1)
plot(AUC_BirdsPhylo, main="Plug & Play Phylo ROC; Birds")
plot(AUC_RF_BirdsPhylo, main="Random Forest Traits ROC; Birds")
mtext(paste("AUC", round(AUC_RF_BirdsPhylo$auc, 3), sep="="), side=1)
plot(AUC_birdsVegdist, main="Plug & Play Vegdist(Latent) ROC; Birds")
plot(AUC_birdsVegdist, main="Plug & Play Vegdist(Latent) ROC; Birds")
mtext(paste("AUC", round(AUC_birdsVegdist$auc, 3), sep="="), side=1)
plot(AUC_birdsVegdist, main="Plug & Play Vegdist(Latent) ROC; Birds")
mtext(paste("AUC", round(AUC_birdsVegdist$auc, 3), sep="="), side=1)
birds_rf_vegdist <- woodedWalk(birds, FrugTraits = c("frugSim"), PlantTraits = c("plantSim"))
AUC_RF_BirdsVegdist <- roc(data=birds_rf_vegdist$test, response=real, predictor=S)
plot(AUC_RF_BirdsVegdist)
AUC_RF_BirdsVegdist
bats_rf_vegdist <- woodedWalk(bats, FrugTraits = c("frugSim"), PlantTraits = c("plantSim"))
AUC_RF_BatsVegdist <- roc(data=bats_rf_vegdist$test, response=real, predictor=S)
plot(AUC_RF_BatsVegdist)
AUC_RF_BatsVegdist
plot(AUC_birdsVegdist, main="Plug & Play Vegdist(Latent) ROC; Birds")
mtext(paste("AUC", round(AUC_birdsVegdist$auc, 3), sep="="), side=1)
par(mfrow=c(3,2))
plot(AUC_birdsTraits, main="Plug & Play Traits ROC; Birds")
mtext(paste("AUC", round(AUC_birdsTraits$auc, 3), sep="="), side=1)
plot(AUC_RF_BirdsTraits, main="Random Forest Traits ROC; Birds")
mtext(paste("AUC", round(AUC_RF_BirdsTraits$auc, 3), sep="="), side=1)
plot(AUC_BirdsPhylo, main="Plug & Play Phylo ROC; Birds")
mtext(paste("AUC", round(AUC_BirdsPhylo$auc, 3), sep="="), side=1)
plot(AUC_RF_BirdsPhylo, main="Random Forest Phylo ROC; Birds")
mtext(paste("AUC", round(AUC_RF_BirdsPhylo$auc, 3), sep="="), side=1)
plot(AUC_birdsVegdist, main="Plug & Play Vegdist(Latent) ROC; Birds")
mtext(paste("AUC", round(AUC_birdsVegdist$auc, 3), sep="="), side=1)
plot(AUC_RF_BirdsVegdist, main="Random Forest Vegdist(Latent) ROC; Birds")
mtext(paste("AUC", round(AUC_RF_BirdsVegdist$auc, 3), sep="="), side=1)
pdf(file = "Birds_PPEvsRF.pdf", height = 11, width=8.5)
par(mfrow=c(3,2))
plot(AUC_birdsTraits, main="Plug & Play Traits ROC; Birds")
mtext(paste("AUC", round(AUC_birdsTraits$auc, 3), sep="="), side=1)
plot(AUC_RF_BirdsTraits, main="Random Forest Traits ROC; Birds")
mtext(paste("AUC", round(AUC_RF_BirdsTraits$auc, 3), sep="="), side=1)
plot(AUC_BirdsPhylo, main="Plug & Play Phylo ROC; Birds")
mtext(paste("AUC", round(AUC_BirdsPhylo$auc, 3), sep="="), side=1)
plot(AUC_RF_BirdsPhylo, main="Random Forest Phylo ROC; Birds")
mtext(paste("AUC", round(AUC_RF_BirdsPhylo$auc, 3), sep="="), side=1)
plot(AUC_birdsVegdist, main="Plug & Play Vegdist(Latent) ROC; Birds")
mtext(paste("AUC", round(AUC_birdsVegdist$auc, 3), sep="="), side=1)
plot(AUC_RF_BirdsVegdist, main="Random Forest Vegdist(Latent) ROC; Birds")
mtext(paste("AUC", round(AUC_RF_BirdsVegdist$auc, 3), sep="="), side=1)
plot(AUC_batsTraits, main="Plug & Play Traits ROC; Birds")
plot(AUC_BatsTraits, main="Plug & Play Traits ROC; Bats")
mtext(paste("AUC", round(AUC_BatsTraits$auc, 3), sep="="), side=1)
plot(AUC_RF_BatsTraits, main="Random Forest Traits ROC; Bats")
plot(AUC_RF_BatsTraits, main="Random Forest Traits ROC; Bats")
mtext(paste("AUC", round(AUC_RF_BatsTraits$auc, 3), sep="="), side=1)
plot(AUC_BatsPhylo, main="Plug & Play Phylo ROC; Bats")
plot(AUC_BatsPhylo, main="Plug & Play Phylo ROC; Bats")
mtext(paste("AUC", round(AUC_BatsPhylo$auc, 3), sep="="), side=1)
plot(AUC_RF_BatsPhylo, main="Random Forest Phylo ROC; Bats")
plot(AUC_RF_BatsPhylo, main="Random Forest Phylo ROC; Bats")
mtext(paste("AUC", round(AUC_RF_BatsPhylo$auc, 3), sep="="), side=1)
plot(AUC_batsVegdist, main="Plug & Play Vegdist(Latent) ROC; Bats")
plot(AUC_BatsVegdist, main="Plug & Play Vegdist(Latent) ROC; Bats")
mtext(paste("AUC", round(AUC_BatsVegdist$auc, 3), sep="="), side=1)
plot(AUC_RF_BatssVegdist, main="Random Forest Vegdist(Latent) ROC; Bats")
plot(AUC_RF_BatsVegdist, main="Random Forest Vegdist(Latent) ROC; Bats")
plot(AUC_RF_BatsVegdist, main="Random Forest Vegdist(Latent) ROC; Bats")
mtext(paste("AUC", round(AUC_RF_BatsVegdist$auc, 3), sep="="), side=1)
#pdf(file = "Bats_PPEvsRF.pdf", height = 11, width=8.5)
par(mfrow=c(3,2))
plot(AUC_BatsTraits, main="Plug & Play Traits ROC; Bats")
mtext(paste("AUC", round(AUC_BatsTraits$auc, 3), sep="="), side=1)
plot(AUC_RF_BatsTraits, main="Random Forest Traits ROC; Bats")
mtext(paste("AUC", round(AUC_RF_BatsTraits$auc, 3), sep="="), side=1)
plot(AUC_BatsPhylo, main="Plug & Play Phylo ROC; Bats")
mtext(paste("AUC", round(AUC_BatsPhylo$auc, 3), sep="="), side=1)
plot(AUC_RF_BatsPhylo, main="Random Forest Phylo ROC; Bats")
mtext(paste("AUC", round(AUC_RF_BatsPhylo$auc, 3), sep="="), side=1)
plot(AUC_BatsVegdist, main="Plug & Play Vegdist(Latent) ROC; Bats")
mtext(paste("AUC", round(AUC_BatsVegdist$auc, 3), sep="="), side=1)
plot(AUC_RF_BatsVegdist, main="Random Forest Vegdist(Latent) ROC; Bats")
mtext(paste("AUC", round(AUC_RF_BatsVegdist$auc, 3), sep="="), side=1)
pdf(file = "Bats_PPEvsRF.pdf", height = 11, width=8.5)
par(mfrow=c(3,2))
plot(AUC_BatsTraits, main="Plug & Play Traits ROC; Bats")
mtext(paste("AUC", round(AUC_BatsTraits$auc, 3), sep="="), side=1)
plot(AUC_RF_BatsTraits, main="Random Forest Traits ROC; Bats")
mtext(paste("AUC", round(AUC_RF_BatsTraits$auc, 3), sep="="), side=1)
plot(AUC_BatsPhylo, main="Plug & Play Phylo ROC; Bats")
mtext(paste("AUC", round(AUC_BatsPhylo$auc, 3), sep="="), side=1)
plot(AUC_RF_BatsPhylo, main="Random Forest Phylo ROC; Bats")
mtext(paste("AUC", round(AUC_RF_BatsPhylo$auc, 3), sep="="), side=1)
plot(AUC_BatsVegdist, main="Plug & Play Vegdist(Latent) ROC; Bats")
mtext(paste("AUC", round(AUC_BatsVegdist$auc, 3), sep="="), side=1)
plot(AUC_RF_BatsVegdist, main="Random Forest Vegdist(Latent) ROC; Bats")
mtext(paste("AUC", round(AUC_RF_BatsVegdist$auc, 3), sep="="), side=1)
plot(AUC_birdsVegdist, main="Plug & Play Vegdist(Latent) ROC; Birds")
hist(degree_distribution(batweb))
