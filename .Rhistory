temp
proj1(Nt=50,Pt=temp[[2]],c=0,lambda=2.8, Rt=1)
temp <- proj1(Nt=50,Pt=1,c=1,lambda=2.8, Rt=1)
temp
proj1(Nt=50,Pt=temp[[2]],c=1,lambda=2.8, Rt=1)
temp <- proj1(Nt=50,Pt=1,c=0.5,lambda=2.8, Rt=1)
temp
proj1(Nt=50,Pt=temp[[2]],c=0.5,lambda=2.8, Rt=1)
temp <- proj1(Nt=50,Pt=1,c=0,lambda=2.8, Rt=1)
temp
proj1(Nt=50,Pt=temp[[2]],c=0,lambda=2.8, Rt=1)
proj1 <- function(Nt, Pt, c, lambda, Rt){  Nt1 <- Nt*c*lambda*Pt
Nt1 <- Nt*(1-c^2)*(lambda+Pt)*Rt
Pt1 <- Rt*c^1.1
return(list(Nt1, Pt1))
}
temp <- proj1(Nt=50,Pt=1,c=1,lambda=2.8, Rt=1)
temp
proj1(Nt=50,Pt=temp[[2]],c=1,lambda=2.8, Rt=1)
temp <- proj1(Nt=50,Pt=1,c=0.5,lambda=2.8, Rt=1)
temp
proj1(Nt=50,Pt=temp[[2]],c=0.5,lambda=2.8, Rt=1)
temp <- proj1(Nt=50,Pt=1,c=0,lambda=2.8, Rt=1)
temp
proj1(Nt=50,Pt=temp[[2]],c=0,lambda=2.8, Rt=1)
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=0.5)[[1]])
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=0.5)[[1]])
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=1)[[1]])
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=0.1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=0.1)[[1]])
}
proj1 <- function(Nt, Pt, c, lambda, Rt){  Nt1 <- Nt*c*lambda*Pt
Nt1 <- Nt*(1-c^2)*(lambda+Pt)*Rt
Pt1 <- Rt*c
return(list(Nt1, Pt1))
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=0.1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=0.1)[[1]])
}
proj1 <- function(Nt, Pt, c, lambda, Rt){  Nt1 <- Nt*c*lambda*Pt
Nt1 <- Nt*(1-c^2)*(lambda+Pt)*Rt
Pt1 <- Rt*c
return(list(Nt1, Pt1))
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=1)[[1]])
}
proj1 <- function(Nt, Pt, c, lambda, Rt){  Nt1 <- Nt*c*lambda*Pt
Nt1 <- Nt*(1-c^1.1)*(lambda+Pt)*Rt
Pt1 <- Rt*c
return(list(Nt1, Pt1))
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=1)[[1]])
}
proj1 <- function(Nt, Pt, c, lambda, Rt){  Nt1 <- Nt*c*lambda*Pt
Nt1 <- Nt*(1-c^2.5)*(lambda+Pt)*Rt
Pt1 <- Rt*c
return(list(Nt1, Pt1))
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=1)[[1]])
}
proj1 <- function(Nt, Pt, c, lambda, Rt){  Nt1 <- Nt*c*lambda*Pt
Nt1 <- Nt*(1-c^10)*(lambda+Pt)*Rt
Pt1 <- Rt*c
return(list(Nt1, Pt1))
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=1)[[1]])
}
proj1 <- function(Nt, Pt, c, lambda, Rt){  Nt1 <- Nt*c*lambda*Pt
Nt1 <- Nt*(1-c^5)*(lambda+Pt)*Rt
Pt1 <- Rt*c
return(list(Nt1, Pt1))
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=1)[[1]])
}
proj1 <- function(Nt, Pt, c, lambda, Rt, x=5){  Nt1 <- Nt*c*lambda*Pt
Nt1 <- Nt*(1-c^x)*(lambda+Pt)*Rt
Pt1 <- Rt*c
return(list(Nt1, Pt1))
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=1)[[1]])
}
proj1 <- function(Nt, Pt, c, lambda, Rt, x=5){  Nt1 <- Nt*c*lambda*Pt
Nt1 <- Nt*(1-c^x)*(lambda+Pt)*Rt
Pt1 <- Rt*c
return(list(Nt1, Pt1))
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=1)[[1]])
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=1)[[1]])
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=1)[[1]])
}
for(x in seq(0.1,1, by=0.1)){
temp <- proj1(Nt=50,Pt=1,c=x,lambda=2.8, Rt=1)
print(proj1(Nt=50,Pt=temp[[2]],c=x,lambda=1.5, Rt=1)[[1]])
}
proj2 <- function(Nt, Pt, c, lambda, Rt, x=5){  Nt1 <- Nt*c*lambda*Pt
Nt1 <- Nt*(1-c^x)*(lambda+Pt)*Rt
Pt1 <- Rt*c
Nt2 <- Nt*(1-c^x)*(lambda+Pt1)*Rt
return(Nt2)
}
proj2(Nt=50, Pt=1, c=0.1, lambda=2.8, Rt=1)
for(x in seq(0.1,1, by=0.1)){
proj2(Nt=50, Pt=1, c=x, lambda=2.8, Rt=1)
}
for(x in seq(0.1,1, by=0.1)){
print(proj2(Nt=50, Pt=1, c=x, lambda=2.8, Rt=1))
}
for(x in seq(0.1,1, by=0.1)){
print(proj2(Nt=50, Pt=1, c=x, lambda=2.8, Rt=0.1))
}
overby <- seq(0,1, by=0.01)
overby <- seq(0,1, by=0.01)
for(x in overby){
vals <- proj2(Nt=50, Pt=1, c=x, lambda=2.8, Rt=1)
}
max(vals)
which.max(vals)
vals
temp <- NULL
overby <- seq(0,1, by=0.01)
temp <- NULL
for(x in overby){
temp <- proj2(Nt=50, Pt=1, c=x, lambda=2.8, Rt=1)
vals <- rbind(temp, vals)
}
which.max(vals)
overby[which.max(vals)]
overby <- seq(0,1, by=0.01)
temp <- NULL
for(x in overby){
temp <- proj2(Nt=50, Pt=1, c=x, lambda=2.8, Rt=0.1)
vals <- rbind(temp, vals)
}
overby[which.max(vals)]
vals
which.max(vals)
overby[which.max(vals)]
overby <- seq(0,1, by=0.01)
temp <- NULL
for(x in overby){
temp <- proj2(Nt=50, Pt=1, c=x, lambda=2.8, Rt=0.1)
vals <- rbind(temp, vals)
}
overby[which.max(vals)]
overby <- seq(0,1, by=0.01)
vals <- NULL
for(x in overby){
temp <- proj2(Nt=50, Pt=1, c=x, lambda=2.8, Rt=1)
vals <- rbind(temp, vals)
}
overby[which.max(vals)]
overby <- seq(0,1, by=0.01)
vals <- NULL
for(x in overby){
temp <- proj2(Nt=50, Pt=1, c=x, lambda=2.8, Rt=0.1)
vals <- rbind(temp, vals)
}
overby[which.max(vals)]
?optim()
proj2(Nt=50, Pt=1, c=0.1, lambda=2.8, Rt=1)
proj2(Nt=50, Pt=1, c=cseq(0,1,by=0.1), lambda=2.8, Rt=1)
proj2(Nt=50, Pt=1, c=seq(0,1,by=0.1), lambda=2.8, Rt=1)
proj2(Nt=50, Pt=1, c=seq(0,1,by=0.01), lambda=2.8, Rt=1)
which.max(proj2(Nt=50, Pt=1, c=seq(0,1,by=0.01), lambda=2.8, Rt=1))
seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=1, c=seq(0,1,by=0.01), lambda=2.8, Rt=1))]
seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=1, c=seq(0,1,by=0.01), lambda=2.8, Rt=0.1))]
seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=1, c=seq(0,1,by=0.01), lambda=2.8, Rt=1))]
seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=1, c=seq(0,1,by=0.01), lambda=2.8, Rt=1.9))]
t1 <- proj1(Nt=50, Pt=1,c=optc, lambda=2.8, x=5)
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=1, c=seq(0,1,by=0.01), lambda=2.8, Rt=1))] #find the value of c that optimized Nt+2
t1 <- proj1(Nt=50, Pt=1,c=optc, lambda=2.8, x=5)
for(i in 1:ngen){
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=1, c=seq(0,1,by=0.01), lambda=2.8, Rt=1))] #find the value of c that optimized Nt+2
t1 <- proj1(Nt=50, Pt=1,c=optc, lambda=2.8, x=5, Rt=1)
}
ngen <- 4
ngen <- 4
for(i in 1:ngen){
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=1, c=seq(0,1,by=0.01), lambda=2.8, Rt=1))] #find the value of c that optimized Nt+2
t1 <- proj1(Nt=50, Pt=1,c=optc, lambda=2.8, x=5, Rt=1)
}
View(t1)
init <- data.frame(Nt=50, Pt=1)
state <- data.frame(Nt=50, Pt=1)
state <- data.frame(Nt=50, Pt=1)
state <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=1)
state
state <- data.frame(Nt=50, Pt=1)
output <- state
ngen <- 4
for(i in 1:ngen){
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=1, c=seq(0,1,by=0.01), lambda=2.8, Rt=1))] #find the value of c that optimized Nt+2
state <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=1)
output <- rbind(state, output)
}
state
output
state <- data.frame(Nt=50, Pt=1)
output <- state
ngen <- 4
for(i in 1:ngen){
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=1, c=seq(0,1,by=0.01), lambda=2.8, Rt=1))] #find the value of c that optimized Nt+2
state <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=1)
output <- rbind(state, output)
}
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=state$Pt, c=seq(0,1,by=0.01), lambda=2.8, Rt=1))] #find the value of c that optimized Nt+2
state <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=1)
output <- rbind(output, state)
output <- rbind(output, state)
output
state
state <- matrix(Nt=50, Pt=1)
state <- as.matrix(Nt=50, Pt=1)
for(i in 1:ngen){
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=state$Pt, c=seq(0,1,by=0.01), lambda=2.8, Rt=1))] #find the value of c that optimized Nt+2
state <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=1)
colnames(state) <-c("Nt", "Pt")
output <- rbind(output, state)
}
state <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=1)
state
state <- data.frame(proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=1))
state
state$Pt
state <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=1)
temp <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=1)
temp
state[1,]
state <- data.frame(Nt=50, Pt=1)
state[1,]
state[1,] <- c(temp[[1]], temp[[2]])
for(i in 1:ngen){
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=state$Pt, c=seq(0,1,by=0.01), lambda=2.8, Rt=1))] #find the value of c that optimized Nt+2
temp <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=1)
state[1,] <- c(temp[[1]], temp[[2]])
output <- rbind(output, state)
}
state <- data.frame(Nt=50, Pt=1)
output <- state
ngen <- 4
for(i in 1:ngen){
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=state$Pt, c=seq(0,1,by=0.01), lambda=2.8, Rt=1))] #find the value of c that optimized Nt+2
temp <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=1)
state[1,] <- c(temp[[1]], temp[[2]])
output <- rbind(output, state)
}
View(output)
Rvec <- c(1,0.2,1,1)
for(i in 1:ngen){
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=state$Pt, c=seq(0,1,by=0.01), lambda=2.8, Rt=Rvec[i]))] #find the value of c that optimized Nt+2
temp <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=Rvec[i])
state[1,] <- c(temp[[1]], temp[[2]])
output <- rbind(output, state)
}
state <- data.frame(Nt=50, Pt=1)
output <- state
ngen <- 4
Rvec <- c(1,0.2,1,1)
for(i in 1:ngen){
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=state$Pt, c=seq(0,1,by=0.01), lambda=2.8, Rt=Rvec[i]))] #find the value of c that optimized Nt+2
temp <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=Rvec[i])
state[1,] <- c(temp[[1]], temp[[2]])
output <- rbind(output, state)
}
View(output)
simbad <- function(Rvec){
state <- data.frame(Nt=50, Pt=1)
output <- state
ngen <- 4
for(i in 1:ngen){
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=state$Pt, c=seq(0,1,by=0.01), lambda=2.8, Rt=Rvec[i]))] #find the value of c that optimized Nt+2
temp <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=2.8, x=5, Rt=Rvec[i])
state[1,] <- c(temp[[1]], temp[[2]])
output <- rbind(output, state)
}
return(output)
}
simbad(Rvec=c(1,0.2,1,1))
simbad(Rvec=c(1,0.2,1,1))$Nt
plot(tmp2$gen, tmp2$mn, type='b',
xlab='Generation', ylab='Growth rate',
`pch=21, las=1, col=adjustcolor(1, 0.5),
bg=colz[1], ylim=c(-3.5,3.5), xlim=c(1,5), cex=1.5)
abline(h=0, lwd=2, col='grey')
)
)_
)
plot(x=1:5,y=simbad$Nt)
)
plot(x=1:5,y=simbad$Nt)
simbad$Nt
plot(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt)
plot(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt, col="red")
plot(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt, col="red", typ="b")
grDat2 <- plotGR0(grDat, colz=topo.colors(6))#colz=RColorBrewer::brewer.pal(6,'YlOrRd'))
colz=topo.colors(6)
plot(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt, col=colz[1], typ="b")
plot(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt, col=colz[1], typ="b")
plot(x=1:5,y=simbad(Rvec=c(1,0.4,1,1))$Nt, col=colz[2], typ="b")
plot(x=1:5,y=simbad(Rvec=c(1,0.6,1,1))$Nt, col=colz[3], typ="b")
plot(x=1:5,y=simbad(Rvec=c(1,0.8,1,1))$Nt, col=colz[4], typ="b")
plot(x=1:5,y=simbad(Rvec=c(1,1,1,1))$Nt, col=colz[5], typ="b")
plot(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt, col=colz[1], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.4,1,1))$Nt, col=colz[2], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.6,1,1))$Nt, col=colz[3], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.8,1,1))$Nt, col=colz[4], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,1,1,1))$Nt, col=colz[5], typ="b")
plot(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt/50, col=colz[1], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.4,1,1))$Nt/50, col=colz[2], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.6,1,1))$Nt/50, col=colz[3], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.8,1,1))$Nt/50, col=colz[4], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,1,1,1))$Nt/50, col=colz[5], typ="b")
simbad <- function(Rvec){
state <- data.frame(Nt=50, Pt=1)
output <- state
ngen <- 4
for(i in 1:ngen){
optc <- seq(0,1,by=0.01)[which.max(proj2(Nt=50, Pt=state$Pt, c=seq(0,1,by=0.01), lambda=1, Rt=Rvec[i]))] #find the value of c that optimized Nt+2
temp <- proj1(Nt=50, Pt=state$Pt,c=optc, lambda=1, x=5, Rt=Rvec[i])
state[1,] <- c(temp[[1]], temp[[2]])
output <- rbind(output, state)
}
return(output)
}
simbad(Rvec=c(1,0.2,1,1))$Nt
plot(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt/50, col=colz[1], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.4,1,1))$Nt/50, col=colz[2], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.6,1,1))$Nt/50, col=colz[3], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.8,1,1))$Nt/50, col=colz[4], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,1,1,1))$Nt/50, col=colz[5], typ="b")
plot(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt/50, col=colz[1], typ="b")
plot(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt/50, col=colz[1], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.4,1,1))$Nt/50, col=colz[2], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.6,1,1))$Nt/50, col=colz[3], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.8,1,1))$Nt/50, col=colz[4], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,1,1,1))$Nt/50, col=colz[5], typ="b")
plot(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt/50, col=colz[1], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.4,1,1))$Nt/50, col=colz[2], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.6,1,1))$Nt/50, col=colz[3], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.8,1,1))$Nt/50, col=colz[4], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,1,1,1))$Nt/50, col=colz[5], typ="b")
legend('topright', pch=16, col=colz,
title='Percent corn', legend=c(100, 80, 60, 40, 20, 0),
bty='n', ncol=2, pt.cex=1.5)
plot(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt/50, col=colz[1], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.4,1,1))$Nt/50, col=colz[2], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.6,1,1))$Nt/50, col=colz[3], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.8,1,1))$Nt/50, col=colz[4], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,1,1,1))$Nt/50, col=colz[5], typ="b")
legend('bottomright', pch=16, col=colz,
title='Percent corn', legend=c(100, 80, 60, 40, 20, 0),
bty='n', ncol=2, pt.cex=1.5)
lines(x=1:5,y=simbad(Rvec=c(1,0,1,1))$Nt/50, col=colz[1], typ="b")
plot(x=1:5,y=simbad(Rvec=c(1,0,1,1))$Nt/50, col=colz[1], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt/50, col=colz[2], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.4,1,1))$Nt/50, col=colz[3], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.6,1,1))$Nt/50, col=colz[4], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.8,1,1))$Nt/50, col=colz[5], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,1,1,1))$Nt/50, col=colz[6], typ="b")
legend('bottomright', pch=16, col=colz,
title='Percent corn', legend=c(100, 80, 60, 40, 20, 0),
bty='n', ncol=2, pt.cex=1.5)
plot(x=1:5,y=simbad(Rvec=c(1,0,1,1))$Nt/50, col=colz[1], typ="b", ylab="Effective Growth Rate", "Generation")
plot(x=1:5,y=simbad(Rvec=c(1,0,1,1))$Nt/50, col=colz[1], typ="b", ylab="Effective Growth Rate", xlab="Generation")
lines(x=1:5,y=simbad(Rvec=c(1,0.2,1,1))$Nt/50, col=colz[2], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.4,1,1))$Nt/50, col=colz[3], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.6,1,1))$Nt/50, col=colz[4], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,0.8,1,1))$Nt/50, col=colz[5], typ="b")
lines(x=1:5,y=simbad(Rvec=c(1,1,1,1))$Nt/50, col=colz[6], typ="b")
legend('bottomright', pch=16, col=colz,
title='Percent corn', legend=c(100, 80, 60, 40, 20, 0),
bty='n', ncol=2, pt.cex=1.5)
knitr::opts_chunk$set(echo = TRUE)
dat <- read.csv(file="data/GBIF/occs/datura_wrightii.csv")
dat_old <- read.csv(file="data/GBIF/occs/datura_wrightii_old.csv")
bienmapDwrightii <-BIEN_ranges_load_species(species = "Datura wrightii")
#pdf(file="figs/mapping/rawClover.pdf", width=8.5, height=11)
maps::map('world', fill = TRUE, col = "white", main="main")
points(x=dat$decimalLongitude, y=dat$decimalLatitude, col="red")
maps::map('world', fill = TRUE, col = "white", main="main")
points(x=vals$x, y=vals$y, col="red")
#'
#' @param x latitude
#' @param y longitude
#' @param msk environmental mask to use, so that we don't count ocean cells
#' @param method method for calculating hulls (case insentitive). Current acceptable values are "mch" and "alphahull"
#' @param alphaval Alpha value used for calculating alpha hull. Defaults to 20.
#'
#' @returns geographic range size in terms of # of cells covered in environmental mask
getArea <- function(x,y, equalArea=TRUE, msk, method, alphaval=20, returnHull=TRUE){
if(tolower(method) %in% c("mch", "alphahull")==FALSE){
stop("No usable method provided")
}
rem <- which(is.na(x) | is.na(y))
if(any(rem)){
x <- x[-rem]
y <- y[-rem]
}
if(tolower(method)=="mch"){ #Use grDevices to create convex hull
tmp <- grDevices::chull(x,y)
x <- x[tmp]
y <- y[tmp]
poly <- sf::st_polygon(cbind(list(cbind(c(x, x[1]), c(y, y[1]))))) #Create a sf polygon from the mch coords
polyvec <- terra::vect(poly) #convert to terra vect iobject for terra::mask()
}
if(tolower(method)=="alphahull"){ #Use alphaHull to creat alpha hulls
tmp <-ashape(x = x, y=y, alpha = alphaval)
tmp <- data.frame(tmp$edges)[,c( 'x1', 'y1', 'x2', 'y2')]
l <- st_linestring(matrix(as.numeric(tmp[1,]), ncol=2, byrow = T))
for(i in 2:nrow(tmp)){
l <- c(l, st_linestring(matrix(as.numeric(tmp[i,]), ncol=2, byrow = T)))
}
polyvec <- vect(st_sf(geom = st_sfc(l), crs = crs(msk)) %>% st_polygonize() %>% st_collection_extract())
}
crs(polyvec) <- crs(msk)
tempMask <-  mask(msk, polyvec) #mask our temperature data by the polygon (this maintains 0 for oceans and whatnot)
df_dat <- terra::as.data.frame(tempMask[[1]], na.rm=T) #Extract the non NA values within the mask
cellcount <- nrow(df_dat)
if(returnHull==FALSE){
return(cellcount)
}
if(returnHull==TRUE){
ret <- list(count=cellcount, pgon=polyvec)
return(ret)
}
}
c <- getArea(x=US$x, y=US$y, msk=tempGlob, method="mch")
c <- getArea(x=US$x, y=US$y, msk=tempGlob, method="mch")
maps::map('world', fill = TRUE, col = "white")
maps::map('world', fill = TRUE, col = "white")
plot(redClover, col="navy", add=T)
clist <- c("Asia","Europe","Africa","Oceania","North America","Antarctica","South America")
input <- vals
knitr::opts_chunk$set(echo = TRUE)
load("Data.nosync/Results/fullReplicateRF_predicts.Rda")
#Extracting all predictions from all replicates takes a while-saved as an output object for conenience
fullnetworkPredicts <- NULL
for(i in 1:100){
for(j in 1:7){
temp <- full_output[[i]][[j]]
temp$model <- names(full_output[[i]][j])
temp$run <- i
fullnetworkPredicts <- rbind(fullnetworkPredicts, temp)
}
}
fullPredictsSummary <- fullnetworkPredicts %>% group_by(., model, Frugivore_Species, Plant_Species) %>% dplyr::summarise(., avg=mean(S), std=sd(S))
library(tidyverse)
library(magrittr)
library(igraph)
library(pROC)
library(BIEN)
library(np)
library(PVR)
library(ape)
library("phytools")
#library(tictoc)
library(corrplot)
library(phytools)
setwd("~/Documents/Fruglink")
knitr::purl("Fruglink_Analysis.Rmf")
knitr::purl("Fruglink_Analysis.Rmd")
ls
pwd
pwd()
getwd()
knitr::purl("Fruglink_Analysis.Rmd")
knitr::purl("Full_Analysis.Rmd")
library(BIEN)
performanceSummary
ggplot(data=varimporSummary, aes(y=trait2, x=avg, fill=model))+geom_col(position = position_dodge(), width = 0.9)+theme_classic()+
scale_fill_manual(values = alpha(c("Phy" = "#ff2929",
"Traits" = "#E0E411",
"Latent" = "#11E0E4",
"PhyTraits" = "#ff9a57",
"TraitsLatent" = "#79E27B",
"PhyLatent" = "#7B79E2",
"Trio" = "#a05a2c"
), 1.0))+
geom_errorbar(aes(xmin=avg-sd, xmax=avg+sd), width=.1,
position=position_dodge(.9))+
theme(axis.text.y = element_text(colour = colKey, size = 8), legend.position = "none")+xlab("Gini Importance Score")+ylab("Variable")+scale_x_continuous(expand=c(0, 0))
