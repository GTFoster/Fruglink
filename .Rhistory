hyperFunc <- function(dat){
uniqdat <- unique(dplyr::select(dat, Frugivore_Species, Plant_Species))
dat <- uniqdat
web <- data.frame(
from = uniqdat$Frugivore_Species,
to = uniqdat$Plant_Species
) %>% graph_from_data_frame(directed=FALSE) #Create a web based on our input edgelist
edge_set <- sample(1:length(E(web)), 0.8*length(E(web)), replace=FALSE) #sample our web to find edges to include
train <- igraph::delete.edges(web, edge_set) #Remove test from train graph
test <- igraph::delete.edges(web, E(web)[E(web) %in% edge_set==FALSE]) #Remove train edges from test graph
A <- as_adjacency_matrix(train, sparse = FALSE) #A = Training Adjacency matrix
Aprime <- as_adjacency_matrix(test, sparse = FALSE) #A' = Testing Adjacency Matrix
V_train <- eigen(A)$values #V_train = Eigenvalues of A
U_train <-  eigen(A)$vector #V_train = Eigenvectors of A
#V_test <- eigen(Aprime)$values #V_train = Eigenvalues of A'
#U_test <-  eigen(Aprime)$vector #V_train = Eigenvectors of A'
target_V <- diag(t(U_train) %*% Aprime %*% U_train) #We want to be able to map our
HSPK <- function(alpha){
sum((target_V - alpha*(exp(V_train)-exp(-V_train)))^2) #set up function that returns sum of squared residuals between our target eigenvector and the hyperbolic sin function of our training eigenvectors given an alpha value
}
best_alpha <- optimize(HSPK, interval=c(-100,100)) #Optimize HSPK for alpha
p <- recordPlot()
#plot.new()
{plot(V_train, target_V, pch=19, xlab='x', ylab='y', cex=.25, xlim=c(-10,10))
lines(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train)), col='green')}
V_pred <- best_alpha$minimum*(exp(V_train)-exp(-V_train)) #Now that we've fit alpha, we make predictions based on our training set
Apred <- U_train %*% diag(V_pred) %*% t(U_train) #Turn our predicted eigenvalues into an Matrix
colnames(Apred) <- colnames(A) #Give matrix the same rows and columns
rownames(Apred) <- rownames(A)
Apred <- data.frame(Apred) #set as dataframe
Apred %<>% rownames_to_column(., var="Interactor1") #make our rownames into the first column
Apred_long <- pivot_longer(Apred, cols=2:ncol(Apred)) #pivot longer
colnames(Apred_long) <- c("Frugivore_Species", "Plant_Species", "S") #Rename, S=suitabilty
Apred_long$Plant_Species <- gsub("\\.", " ", Apred_long$Plant_Species) #get rid of pesky periods
Apred_long$Frugivore_Species <- gsub("\\.", " ", Apred_long$Frugivore_Species)
uniqdat$real <- 1 #add key to identify real values
dat_exp <- expand(uniqdat, Frugivore_Species, Plant_Species) #expand to include 0 entries
dat_exp <- left_join(dat_exp, uniqdat, by=c("Frugivore_Species", "Plant_Species")) #add key for real
dat_exp$real[is.na(dat_exp$real)==TRUE] <- 0
dat_exp$Plant_Species <- gsub("\\-", " ", dat_exp$Plant_Species) #remove pesky hyphens
dat_exp <- left_join(dat_exp, Apred_long, by=c("Frugivore_Species", "Plant_Species")) # add in Suitability values
AUC_DoubleDip<- roc(data=dat_exp, response=real, predictor=S) #repredict on the whole network; doesn't exclude 1's from the test
test_edges <- data.frame(get.edgelist(test)) #find what's supposed to be in our test_Set
colnames(test_edges) <- c("Frugivore_Species", "Plant_Species")
test_set <- left_join(test_edges, dat_exp, by=c("Frugivore_Species", "Plant_Species")) #add all true positives from our test set
test_set <- dplyr::filter(dat_exp, real==0) %>% rbind(test_set, .) #Add true negatives!
AUC_Conservative <- roc(data=test_set, response=real, predictor=S)
output <- list(AUC=AUC_Conservative, suits=dat_exp, suits_conserve=test_set, fitplot=p)
return(output)
}
returned <- hyperFunc(dat=dat)
hyperFunc <- function(dat){
uniqdat <- unique(dplyr::select(dat, Frugivore_Species, Plant_Species))
dat <- uniqdat
web <- data.frame(
from = uniqdat$Frugivore_Species,
to = uniqdat$Plant_Species
) %>% graph_from_data_frame(directed=FALSE) #Create a web based on our input edgelist
edge_set <- sample(1:length(E(web)), 0.8*length(E(web)), replace=FALSE) #sample our web to find edges to include
train <- igraph::delete.edges(web, edge_set) #Remove test from train graph
test <- igraph::delete.edges(web, E(web)[E(web) %in% edge_set==FALSE]) #Remove train edges from test graph
A <- as_adjacency_matrix(train, sparse = FALSE) #A = Training Adjacency matrix
Aprime <- as_adjacency_matrix(test, sparse = FALSE) #A' = Testing Adjacency Matrix
V_train <- eigen(A)$values #V_train = Eigenvalues of A
U_train <-  eigen(A)$vector #V_train = Eigenvectors of A
#V_test <- eigen(Aprime)$values #V_train = Eigenvalues of A'
#U_test <-  eigen(Aprime)$vector #V_train = Eigenvectors of A'
target_V <- diag(t(U_train) %*% Aprime %*% U_train) #We want to be able to map our
HSPK <- function(alpha){
sum((target_V - alpha*(exp(V_train)-exp(-V_train)))^2) #set up function that returns sum of squared residuals between our target eigenvector and the hyperbolic sin function of our training eigenvectors given an alpha value
}
best_alpha <- optimize(HSPK, interval=c(-100,100)) #Optimize HSPK for alpha
#p <- recordPlot()
#plot.new()
#{plot(V_train, target_V, pch=19, xlab='x', ylab='y', cex=.25, xlim=c(-10,10))
#lines(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train)), col='green')}
V_pred <- best_alpha$minimum*(exp(V_train)-exp(-V_train)) #Now that we've fit alpha, we make predictions based on our training set
Apred <- U_train %*% diag(V_pred) %*% t(U_train) #Turn our predicted eigenvalues into an Matrix
colnames(Apred) <- colnames(A) #Give matrix the same rows and columns
rownames(Apred) <- rownames(A)
Apred <- data.frame(Apred) #set as dataframe
Apred %<>% rownames_to_column(., var="Interactor1") #make our rownames into the first column
Apred_long <- pivot_longer(Apred, cols=2:ncol(Apred)) #pivot longer
colnames(Apred_long) <- c("Frugivore_Species", "Plant_Species", "S") #Rename, S=suitabilty
Apred_long$Plant_Species <- gsub("\\.", " ", Apred_long$Plant_Species) #get rid of pesky periods
Apred_long$Frugivore_Species <- gsub("\\.", " ", Apred_long$Frugivore_Species)
uniqdat$real <- 1 #add key to identify real values
dat_exp <- expand(uniqdat, Frugivore_Species, Plant_Species) #expand to include 0 entries
dat_exp <- left_join(dat_exp, uniqdat, by=c("Frugivore_Species", "Plant_Species")) #add key for real
dat_exp$real[is.na(dat_exp$real)==TRUE] <- 0
dat_exp$Plant_Species <- gsub("\\-", " ", dat_exp$Plant_Species) #remove pesky hyphens
dat_exp <- left_join(dat_exp, Apred_long, by=c("Frugivore_Species", "Plant_Species")) # add in Suitability values
AUC_DoubleDip<- roc(data=dat_exp, response=real, predictor=S) #repredict on the whole network; doesn't exclude 1's from the test
test_edges <- data.frame(get.edgelist(test)) #find what's supposed to be in our test_Set
colnames(test_edges) <- c("Frugivore_Species", "Plant_Species")
test_set <- left_join(test_edges, dat_exp, by=c("Frugivore_Species", "Plant_Species")) #add all true positives from our test set
test_set <- dplyr::filter(dat_exp, real==0) %>% rbind(test_set, .) #Add true negatives!
AUC_Conservative <- roc(data=test_set, response=real, predictor=S)
output <- list(AUC=AUC_Conservative, suits=dat_exp, suits_conserve=test_set, fitplot=p)
return(output)
}
returned <- hyperFunc(dat=dat)
hyperFunc <- function(dat){
uniqdat <- unique(dplyr::select(dat, Frugivore_Species, Plant_Species))
dat <- uniqdat
web <- data.frame(
from = uniqdat$Frugivore_Species,
to = uniqdat$Plant_Species
) %>% graph_from_data_frame(directed=FALSE) #Create a web based on our input edgelist
edge_set <- sample(1:length(E(web)), 0.8*length(E(web)), replace=FALSE) #sample our web to find edges to include
train <- igraph::delete.edges(web, edge_set) #Remove test from train graph
test <- igraph::delete.edges(web, E(web)[E(web) %in% edge_set==FALSE]) #Remove train edges from test graph
A <- as_adjacency_matrix(train, sparse = FALSE) #A = Training Adjacency matrix
Aprime <- as_adjacency_matrix(test, sparse = FALSE) #A' = Testing Adjacency Matrix
V_train <- eigen(A)$values #V_train = Eigenvalues of A
U_train <-  eigen(A)$vector #V_train = Eigenvectors of A
#V_test <- eigen(Aprime)$values #V_train = Eigenvalues of A'
#U_test <-  eigen(Aprime)$vector #V_train = Eigenvectors of A'
target_V <- diag(t(U_train) %*% Aprime %*% U_train) #We want to be able to map our
HSPK <- function(alpha){
sum((target_V - alpha*(exp(V_train)-exp(-V_train)))^2) #set up function that returns sum of squared residuals between our target eigenvector and the hyperbolic sin function of our training eigenvectors given an alpha value
}
best_alpha <- optimize(HSPK, interval=c(-100,100)) #Optimize HSPK for alpha
#p <- recordPlot()
#plot.new()
#{plot(V_train, target_V, pch=19, xlab='x', ylab='y', cex=.25, xlim=c(-10,10))
#lines(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train)), col='green')}
V_pred <- best_alpha$minimum*(exp(V_train)-exp(-V_train)) #Now that we've fit alpha, we make predictions based on our training set
Apred <- U_train %*% diag(V_pred) %*% t(U_train) #Turn our predicted eigenvalues into an Matrix
colnames(Apred) <- colnames(A) #Give matrix the same rows and columns
rownames(Apred) <- rownames(A)
Apred <- data.frame(Apred) #set as dataframe
Apred %<>% rownames_to_column(., var="Interactor1") #make our rownames into the first column
Apred_long <- pivot_longer(Apred, cols=2:ncol(Apred)) #pivot longer
colnames(Apred_long) <- c("Frugivore_Species", "Plant_Species", "S") #Rename, S=suitabilty
Apred_long$Plant_Species <- gsub("\\.", " ", Apred_long$Plant_Species) #get rid of pesky periods
Apred_long$Frugivore_Species <- gsub("\\.", " ", Apred_long$Frugivore_Species)
uniqdat$real <- 1 #add key to identify real values
dat_exp <- expand(uniqdat, Frugivore_Species, Plant_Species) #expand to include 0 entries
dat_exp <- left_join(dat_exp, uniqdat, by=c("Frugivore_Species", "Plant_Species")) #add key for real
dat_exp$real[is.na(dat_exp$real)==TRUE] <- 0
dat_exp$Plant_Species <- gsub("\\-", " ", dat_exp$Plant_Species) #remove pesky hyphens
dat_exp <- left_join(dat_exp, Apred_long, by=c("Frugivore_Species", "Plant_Species")) # add in Suitability values
AUC_DoubleDip<- roc(data=dat_exp, response=real, predictor=S) #repredict on the whole network; doesn't exclude 1's from the test
test_edges <- data.frame(get.edgelist(test)) #find what's supposed to be in our test_Set
colnames(test_edges) <- c("Frugivore_Species", "Plant_Species")
test_set <- left_join(test_edges, dat_exp, by=c("Frugivore_Species", "Plant_Species")) #add all true positives from our test set
test_set <- dplyr::filter(dat_exp, real==0) %>% rbind(test_set, .) #Add true negatives!
AUC_Conservative <- roc(data=test_set, response=real, predictor=S)
output <- list(AUC=AUC_Conservative, suits=dat_exp, suits_conserve=test_set)
return(output)
}
returned <- hyperFunc(dat=dat)
plot(returned$AUC)
returned$AUC
clarg <- returned$suits
returned_bats <- hyperFunc(dat=bats)
plot(returned_bats$AUC)
returned_bats$AUC
clarg <- returned_bats$suits
birds <- dplyr::filter
returned_birds <- hyperFunc(dat=bats)
plot(returned_birds$AUC)
returned_birds$AUC
clarg <- returned_birds$suits
#bat_AUC <- hyperFunc(bats)
#plot(bat_AUC)
#bat_AUC
dat <- read.csv("Data.nosync/ATLANTIC_frugivory.csv")
bats <- dplyr::filter(dat, Frug_Group=="Bats")
bats <- unique(dplyr::select(bats, Frugivore_Species, Plant_Species))
batweb <- data.frame(
from = bats$Frugivore_Species,
to = bats$Plant_Species
) %>% graph_from_data_frame(directed=FALSE)
V(batweb)$type <- bipartite.mapping(batweb)$type
plot(batweb, layout=layout_as_bipartite(batweb))
edge_set <- sample(1:length(E(batweb)), 0.8*length(E(batweb)), replace=FALSE)
train <- igraph::delete.edges(batweb, edge_set)
test <- igraph::delete.edges(batweb, E(batweb)[E(batweb) %in% edge_set==FALSE])
A <- as_adjacency_matrix(train, sparse = FALSE)
Aprime <- as_adjacency_matrix(test, sparse = FALSE)
V_train <- eigen(A)$values
U_train <-  eigen(A)$vector
V_test <- eigen(Aprime)$values
U_test <-  eigen(Aprime)$vector
target_V <- diag(t(U_train) %*% Aprime %*% U_train)
#fit1 <- lm(target_V~exp(V_train)-exp(-V_train))
HSPK <- function(alpha){
sum((target_V - alpha*(exp(V_train)-exp(-V_train)))^2)
}
best_alpha <- optimize(HSPK, interval=c(-100,100))
plot(V_train, target_V, pch=19, xlab='x', ylab='y', cex=.25, xlim=c(-10,10))
lines(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train)), col='green')
ggplot(data=NULL, aes(x=V_train, y=target_V))+geom_point()
ggplot(data=NULL, aes(x=V_train, y=target_V))+geom_point()+geom_line(aes(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train)), col='green'))
ggplot(data=NULL, aes(x=V_train, y=target_V))+geom_point()+geom_line(aes(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train))), col='green')
plot(V_train, target_V, pch=19, xlab='x', ylab='y', cex=.25, xlim=c(-10,10))
lines(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train)), col='green')
plot(V_train, target_V, pch=19, xlab='x', ylab='y', cex=.25, xlim=c(-10,10))
lines(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train)), col='green')
ggplot(data=NULL, aes(x=V_train, y=target_V))+geom_point()+geom_line(aes(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train))), col='green')
max(V_train)
hist(V_train)
library(ggplot2)
ggplot(data=NULL, aes(x=V_train, y=target_V))+geom_point()+geom_line(aes(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train))), col='green')
ggplot(data=NULL, aes(x=V_train, y=target_V))+geom_point()+geom_line(aes(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train))), col='green')+xlab("Stuff")
ggplot(data=NULL, aes(x=V_train, y=target_V))+geom_point()+geom_line(aes(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train))), col='green')+xlab
ggplot(data=NULL, aes(x=V_train, y=target_V))+geom_point()+geom_line(aes(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train))), col='green')
ggplot(data=NULL, aes(x=V_train, y=target_V))+geom_point()+geom_line(aes(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train))), col='green')+xlab("Eigenvalues of A")+ylab("Eigenvalues of A'")
dat <- read.csv("Data.nosync/ATLANTIC_frugivory.csv")
birds <- dplyr::filter(dat, Frugivore_Class="Aves")
birds <- dplyr::filter(dat, Frugivore_Class=="Aves")
birds <- dplyr::filter(dat, Frugivore_class=="Aves")
View(dat)
birds <- dplyr::filter(dat, Frug_Class=="Aves")
hyperFunc <- function(dat){
uniqdat <- unique(dplyr::select(dat, Frugivore_Species, Plant_Species))
dat <- uniqdat
web <- data.frame(
from = uniqdat$Frugivore_Species,
to = uniqdat$Plant_Species
) %>% graph_from_data_frame(directed=FALSE) #Create a web based on our input edgelist
edge_set <- sample(1:length(E(web)), 0.8*length(E(web)), replace=FALSE) #sample our web to find edges to include
train <- igraph::delete.edges(web, edge_set) #Remove test from train graph
test <- igraph::delete.edges(web, E(web)[E(web) %in% edge_set==FALSE]) #Remove train edges from test graph
A <- as_adjacency_matrix(train, sparse = FALSE) #A = Training Adjacency matrix
Aprime <- as_adjacency_matrix(test, sparse = FALSE) #A' = Testing Adjacency Matrix
V_train <- eigen(A)$values #V_train = Eigenvalues of A
U_train <-  eigen(A)$vector #V_train = Eigenvectors of A
#V_test <- eigen(Aprime)$values #V_train = Eigenvalues of A'
#U_test <-  eigen(Aprime)$vector #V_train = Eigenvectors of A'
target_V <- diag(t(U_train) %*% Aprime %*% U_train) #We want to be able to map our
HSPK <- function(alpha){
sum((target_V - alpha*(exp(V_train)-exp(-V_train)))^2) #set up function that returns sum of squared residuals between our target eigenvector and the hyperbolic sin function of our training eigenvectors given an alpha value
}
best_alpha <- optimize(HSPK, interval=c(-100,100)) #Optimize HSPK for alpha
p <- ggplot(data=NULL, aes(x=V_train, y=target_V))+
geom_point()+
geom_line(aes(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train))), col='green')+xlab("Eigenvalues of A")+
ylab("Eigenvalues of A'")
V_pred <- best_alpha$minimum*(exp(V_train)-exp(-V_train)) #Now that we've fit alpha, we make predictions based on our training set
Apred <- U_train %*% diag(V_pred) %*% t(U_train) #Turn our predicted eigenvalues into an Matrix
colnames(Apred) <- colnames(A) #Give matrix the same rows and columns
rownames(Apred) <- rownames(A)
Apred <- data.frame(Apred) #set as dataframe
Apred %<>% rownames_to_column(., var="Interactor1") #make our rownames into the first column
Apred_long <- pivot_longer(Apred, cols=2:ncol(Apred)) #pivot longer
colnames(Apred_long) <- c("Frugivore_Species", "Plant_Species", "S") #Rename, S=suitabilty
Apred_long$Plant_Species <- gsub("\\.", " ", Apred_long$Plant_Species) #get rid of pesky periods
Apred_long$Frugivore_Species <- gsub("\\.", " ", Apred_long$Frugivore_Species)
uniqdat$real <- 1 #add key to identify real values
dat_exp <- expand(uniqdat, Frugivore_Species, Plant_Species) #expand to include 0 entries
dat_exp <- left_join(dat_exp, uniqdat, by=c("Frugivore_Species", "Plant_Species")) #add key for real
dat_exp$real[is.na(dat_exp$real)==TRUE] <- 0
dat_exp$Plant_Species <- gsub("\\-", " ", dat_exp$Plant_Species) #remove pesky hyphens
dat_exp <- left_join(dat_exp, Apred_long, by=c("Frugivore_Species", "Plant_Species")) # add in Suitability values
AUC_DoubleDip<- roc(data=dat_exp, response=real, predictor=S) #repredict on the whole network; doesn't exclude 1's from the test
test_edges <- data.frame(get.edgelist(test)) #find what's supposed to be in our test_Set
colnames(test_edges) <- c("Frugivore_Species", "Plant_Species")
test_set <- left_join(test_edges, dat_exp, by=c("Frugivore_Species", "Plant_Species")) #add all true positives from our test set
test_set <- dplyr::filter(dat_exp, real==0) %>% rbind(test_set, .) #Add true negatives!
AUC_Conservative <- roc(data=test_set, response=real, predictor=S)
output <- list(AUC=AUC_Conservative, suits=dat_exp, suits_conserve=test_set, fitplot=p)
return(output)
}
returned <- hyperFunc(dat=dat)
plot(returned$AUC)
returned$AUC
returned_bats <- hyperFunc(dat=bats)
plot(returned_bats$AUC)
returned_bats$AUC
birds <- dplyr::filter(dat, Frug_Class=="Aves")
returned_birds <- hyperFunc(dat=birds)
plot(returned_birds$AUC)
returned_birds$AUC
returned_birds$AUC
returned$AUC
returned_birds$AUC
returned$fitplot
returned_bats$fitplot
returned_birds$fitplot
plot(returned$AUC)
xreturned$AUC
plot(returned$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned$AUC$auc, 3), sep="="), side=1)
par(mfrow=c(3,2))
plot(returned$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned$AUC$auc, 3), sep="="), side=1)
returned$fitplot
plot(returned_bats$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
returned_bats$fitplot
plot(returned_bats$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
returned_bats$fitplot
par(mfrow=c(3,2))
plot(returned$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned$AUC$auc, 3), sep="="), side=1)
returned$fitplot
plot(returned_bats$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
returned_bats$fitplot
plot(returned_bats$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
returned_bats$fitplot
plot(returned$fitplot)
par(mfrow=c(3,2))
plot(returned$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned$AUC$auc, 3), sep="="), side=1)
plot(returned$fitplot)
plot(returned_bats$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
plot(returned_bats$fitplot)
plot(returned_bats$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
plot(returned_bats$fitplot)
pdf(file="Hypsin Stuff.pdf", height = 8.5, width=11)
par(mfrow=c(3,2))
plot(returned$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned$AUC$auc, 3), sep="="), side=1)
plot(returned$fitplot)
plot(returned_bats$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
plot(returned_bats$fitplot)
plot(returned_bats$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
plot(returned_bats$fitplot)
plot(returned$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned$AUC$auc, 3), sep="="), side=1)
plot(returned$fitplot)
plot(returned_bats$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
plot(returned_bats$fitplot)
plot(returned_bats$AUC, main="HypSin Kernal")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
plot(returned_bats$fitplot)
?gridExtra::grid.arrange
plot(returned$AUC, main="HypSin Kernal - Full Data")
mtext(paste("AUC", round(returned$AUC$auc, 3), sep="="), side=1)
#plot(returned$fitplot)
plot(returned_bats$AUC, main="HypSin Kernal - Bats")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
#plot(returned_bats$fitplot)
plot(returned_bats$AUC, main="HypSin Kernal - Birds")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
#plot(returned_bats$fitplot)
plot(returned$AUC, main="HypSin Kernal - Full Data")
mtext(paste("AUC", round(returned$AUC$auc, 3), sep="="), side=1)
#plot(returned$fitplot)
plot(returned_bats$AUC, main="HypSin Kernal - Bats")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
#plot(returned_bats$fitplot)
plot(returned_birds$AUC, main="HypSin Kernal - Birds")
mtext(paste("AUC", round(returned_birds$AUC$auc, 3), sep="="), side=1)
#plot(returned_bats$fitplot)
pdf(file="Hypsin_Draft.pdf", height = 11, width=8.5)
par(mfrow=c(3,1))
plot(returned$AUC, main="HypSin Kernal - Full Data")
mtext(paste("AUC", round(returned$AUC$auc, 3), sep="="), side=1)
#plot(returned$fitplot)
plot(returned_bats$AUC, main="HypSin Kernal - Bats")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
#plot(returned_bats$fitplot)
plot(returned_birds$AUC, main="HypSin Kernal - Birds")
mtext(paste("AUC", round(returned_birds$AUC$auc, 3), sep="="), side=1)
#plot(returned_bats$fitplot)
grid.arrange(returned$fitplot, returned_bats$fitplot, returned_bats$fitplot, nrow = 3)
gridExtra::grid.arrange(returned$fitplot, returned_bats$fitplot, returned_bats$fitplot, nrow = 3)
pdf(file="Hypsin_Fitplots_Draft.pdf", height = 11, width=8.5)
gridExtra::grid.arrange(returned$fitplot, returned_bats$fitplot, returned_bats$fitplot, nrow = 3)
pdf(file="Hypsin_Fitplots_Draft.pdf", height = 11, width=8.5)
gridExtra::grid.arrange(returned$fitplot, returned_bats$fitplot, returned_birds$fitplot, nrow = 3)
gridExtra::grid.arrange(returned$fitplot+ggtitle("Full"), returned_bats$fitplot, returned_birds$fitplot, nrow = 3)
pdf(file="Hypsin_Fitplots_Draft.pdf", height = 11, width=8.5)
gridExtra::grid.arrange(returned$fitplot+ggtitle("Full"), returned_bats$fitplot+ggtitle("Bats"), returned_birds$fitplot+ggtitle("Birds"), nrow = 3)
#pdf(file="Hypsin_Draft.pdf", height = 11, width=8.5)
par(mfrow=c(3,1))
plot(returned$AUC, main="HypSin Kernal - Full Data")
mtext(paste("AUC", round(returned$AUC$auc, 3), sep="="), side=1)
#plot(returned$fitplot)
plot(returned_bats$AUC, main="HypSin Kernal - Bats")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
#plot(returned_bats$fitplot)
plot(returned_birds$AUC, main="HypSin Kernal - Birds")
mtext(paste("AUC", round(returned_birds$AUC$auc, 3), sep="="), side=1)
#plot(returned_bats$fitplot)
knitr::opts_chunk$set(echo = TRUE)
library(igraph)
library(tidyverse)
library(ggplot2)
dat <- read.csv("Data.nosync/ATLANTIC_frugivory.csv")
bats <- dplyr::filter(dat, Frug_Group=="Bats")
bats <- unique(dplyr::select(bats, Frugivore_Species, Plant_Species))
batweb <- data.frame(
from = bats$Frugivore_Species,
to = bats$Plant_Species
) %>% graph_from_data_frame(directed=FALSE)
V(batweb)$type <- bipartite.mapping(batweb)$type
plot(batweb, layout=layout_as_bipartite(batweb))
edge_set <- sample(1:length(E(batweb)), 0.8*length(E(batweb)), replace=FALSE)
train <- igraph::delete.edges(batweb, edge_set)
test <- igraph::delete.edges(batweb, E(batweb)[E(batweb) %in% edge_set==FALSE])
A <- as_adjacency_matrix(train, sparse = FALSE)
Aprime <- as_adjacency_matrix(test, sparse = FALSE)
V_train <- eigen(A)$values
U_train <-  eigen(A)$vector
V_test <- eigen(Aprime)$values
U_test <-  eigen(Aprime)$vector
target_V <- diag(t(U_train) %*% Aprime %*% U_train)
#fit1 <- lm(target_V~exp(V_train)-exp(-V_train))
HSPK <- function(alpha){
sum((target_V - alpha*(exp(V_train)-exp(-V_train)))^2)
}
best_alpha <- optimize(HSPK, interval=c(-100,100))
plot(V_train, target_V, pch=19, xlab='x', ylab='y', cex=.25, xlim=c(-10,10))
lines(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train)), col='green')
V_pred <- best_alpha$minimum*(exp(V_train)-exp(-V_train))
Apred <- U_train %*% diag(V_pred) %*% t(U_train) #Yo, why do we have the same function to either take the diagonal or diagonalize an object
colnames(Apred) <- colnames(A)
rownames(Apred) <- rownames(A)
Apred <- data.frame(Apred)
Apred %<>% rownames_to_column(., var="Interactor1")
Apred_long <- pivot_longer(Apred, cols=2:ncol(Apred))
colnames(Apred_long) <- c("Frugivore_Species", "Plant_Species", "S")
Apred_long$Plant_Species <- gsub("\\.", " ", Apred_long$Plant_Species)
Apred_long$Frugivore_Species <- gsub("\\.", " ", Apred_long$Frugivore_Species)
#Apred_long$Plant_Species[Apred_long$Plant_Species=="Solanum ochraceo ferrugineum"] <- "Solanum ochraceo-ferrugineum"
bats$real <- 1
bats_exp <- expand(bats, Frugivore_Species, Plant_Species)
bats_exp <- left_join(bats_exp, bats, by=c("Frugivore_Species", "Plant_Species"))
bats_exp$real[is.na(bats_exp$real)==TRUE] <- 0
bats_exp$Plant_Species <- gsub("\\-", " ", bats_exp$Plant_Species)
bats_exp <- left_join(bats_exp, Apred_long, by=c("Frugivore_Species", "Plant_Species"))
dplyr::filter(bats_exp, is.na(S)==TRUE) ###TEMPORARY-Remove troublesome hyphenated species
AUC_BatsHyperSin <- roc(data=bats_exp, response=real, predictor=S)
plot(AUC_BatsHyperSin)
AUC_BatsHyperSin
test_edges <- data.frame(get.edgelist(test))
colnames(test_edges) <- c("Frugivore_Species", "Plant_Species")
temp <- left_join(test_edges, bats_exp, by=c("Frugivore_Species", "Plant_Species"))
ret <- dplyr::filter(bats_exp, real==0) %>% rbind(temp, .)
AUC_BatsHyperSin <- roc(data=ret, response=real, predictor=S)
plot(AUC_BatsHyperSin)
AUC_BatsHyperSin
hyperFunc <- function(dat){
uniqdat <- unique(dplyr::select(dat, Frugivore_Species, Plant_Species))
dat <- uniqdat
web <- data.frame(
from = uniqdat$Frugivore_Species,
to = uniqdat$Plant_Species
) %>% graph_from_data_frame(directed=FALSE) #Create a web based on our input edgelist
edge_set <- sample(1:length(E(web)), 0.8*length(E(web)), replace=FALSE) #sample our web to find edges to include
train <- igraph::delete.edges(web, edge_set) #Remove test from train graph
test <- igraph::delete.edges(web, E(web)[E(web) %in% edge_set==FALSE]) #Remove train edges from test graph
A <- as_adjacency_matrix(train, sparse = FALSE) #A = Training Adjacency matrix
Aprime <- as_adjacency_matrix(test, sparse = FALSE) #A' = Testing Adjacency Matrix
V_train <- eigen(A)$values #V_train = Eigenvalues of A
U_train <-  eigen(A)$vector #V_train = Eigenvectors of A
#V_test <- eigen(Aprime)$values #V_train = Eigenvalues of A'
#U_test <-  eigen(Aprime)$vector #V_train = Eigenvectors of A'
target_V <- diag(t(U_train) %*% Aprime %*% U_train) #We want to be able to map our
HSPK <- function(alpha){
sum((target_V - alpha*(exp(V_train)-exp(-V_train)))^2) #set up function that returns sum of squared residuals between our target eigenvector and the hyperbolic sin function of our training eigenvectors given an alpha value
}
best_alpha <- optimize(HSPK, interval=c(-100,100)) #Optimize HSPK for alpha
p <- ggplot(data=NULL, aes(x=V_train, y=target_V))+
geom_point()+
geom_line(aes(x=V_train, y=best_alpha$minimum*(exp(V_train)-exp(-V_train))), col='green')+xlab("Eigenvalues of A")+
ylab("Eigenvalues of A'")
V_pred <- best_alpha$minimum*(exp(V_train)-exp(-V_train)) #Now that we've fit alpha, we make predictions based on our training set
Apred <- U_train %*% diag(V_pred) %*% t(U_train) #Turn our predicted eigenvalues into an Matrix
colnames(Apred) <- colnames(A) #Give matrix the same rows and columns
rownames(Apred) <- rownames(A)
Apred <- data.frame(Apred) #set as dataframe
Apred %<>% rownames_to_column(., var="Interactor1") #make our rownames into the first column
Apred_long <- pivot_longer(Apred, cols=2:ncol(Apred)) #pivot longer
colnames(Apred_long) <- c("Frugivore_Species", "Plant_Species", "S") #Rename, S=suitabilty
Apred_long$Plant_Species <- gsub("\\.", " ", Apred_long$Plant_Species) #get rid of pesky periods
Apred_long$Frugivore_Species <- gsub("\\.", " ", Apred_long$Frugivore_Species)
uniqdat$real <- 1 #add key to identify real values
dat_exp <- expand(uniqdat, Frugivore_Species, Plant_Species) #expand to include 0 entries
dat_exp <- left_join(dat_exp, uniqdat, by=c("Frugivore_Species", "Plant_Species")) #add key for real
dat_exp$real[is.na(dat_exp$real)==TRUE] <- 0
dat_exp$Plant_Species <- gsub("\\-", " ", dat_exp$Plant_Species) #remove pesky hyphens
dat_exp <- left_join(dat_exp, Apred_long, by=c("Frugivore_Species", "Plant_Species")) # add in Suitability values
AUC_DoubleDip<- roc(data=dat_exp, response=real, predictor=S) #repredict on the whole network; doesn't exclude 1's from the test
test_edges <- data.frame(get.edgelist(test)) #find what's supposed to be in our test_Set
colnames(test_edges) <- c("Frugivore_Species", "Plant_Species")
test_set <- left_join(test_edges, dat_exp, by=c("Frugivore_Species", "Plant_Species")) #add all true positives from our test set
test_set <- dplyr::filter(dat_exp, real==0) %>% rbind(test_set, .) #Add true negatives!
AUC_Conservative <- roc(data=test_set, response=real, predictor=S)
output <- list(AUC=AUC_Conservative, suits=dat_exp, suits_conserve=test_set, fitplot=p)
return(output)
}
returned <- hyperFunc(dat=dat)
returned_bats <- hyperFunc(dat=bats)
birds <- dplyr::filter(dat, Frug_Class=="Aves")
returned_birds <- hyperFunc(dat=birds)
#pdf(file="Hypsin_Draft.pdf", height = 11, width=8.5)
par(mfrow=c(3,1))
plot(returned$AUC, main="HypSin Kernal - Full Data")
mtext(paste("AUC", round(returned$AUC$auc, 3), sep="="), side=1)
#plot(returned$fitplot)
plot(returned_bats$AUC, main="HypSin Kernal - Bats")
mtext(paste("AUC", round(returned_bats$AUC$auc, 3), sep="="), side=1)
#plot(returned_bats$fitplot)
plot(returned_birds$AUC, main="HypSin Kernal - Birds")
mtext(paste("AUC", round(returned_birds$AUC$auc, 3), sep="="), side=1)
#plot(returned_bats$fitplot)
#pdf(file="Hypsin_Fitplots_Draft.pdf", height = 11, width=8.5)
gridExtra::grid.arrange(returned$fitplot+ggtitle("Full"), returned_bats$fitplot+ggtitle("Bats"), returned_birds$fitplot+ggtitle("Birds"), nrow = 3)
